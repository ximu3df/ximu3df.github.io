<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ximu3df.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ximu&#39;s Blog">
<meta property="og:url" content="http://ximu3df.github.io/index.html">
<meta property="og:site_name" content="Ximu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ximu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ximu3df.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ximu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ximu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/11/16/games104%E7%AC%94%E8%AE%B01-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/16/games104%E7%AC%94%E8%AE%B01-3/" class="post-title-link" itemprop="url">games104笔记1-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-16 10:24:52" itemprop="dateCreated datePublished" datetime="2023-11-16T10:24:52+08:00">2023-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-17 09:49:17" itemprop="dateModified" datetime="2023-11-17T09:49:17+08:00">2023-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h1><p>游戏引擎的定义：构建黑客帝国的底层框架。</p>
<p>游戏引擎不仅仅是渲染，还有更多。</p>
<p>一些游戏引擎的关键点：实时渲染、创作工具（面对各行各业的需求者）、开发平台（面对游戏开发者，尤其是程序员）、工作流（整体框架设计）。</p>
<p>课程目的：建立现代游戏引擎设计的知识体系框架。</p>
<p>课程内容：</p>
<ol>
<li>游戏引擎的层次结构</li>
<li>渲染（各种算法的组成方式与结构）</li>
<li>动画</li>
<li>物理</li>
<li>gameplay系统</li>
<li>特效系统</li>
<li>工具系统</li>
<li>网络</li>
<li>线程同步</li>
<li>前沿技术</li>
</ol>
<h1 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h1><h2 id="游戏引擎的层次"><a href="#游戏引擎的层次" class="headerlink" title="游戏引擎的层次"></a>游戏引擎的层次</h2><ol>
<li>工具层：用户可以直接看到、直接操作的部分。</li>
<li>功能层：画面渲染、场景运动等。</li>
<li>资源层：游戏中用于工作的资源。</li>
<li>核心层：支持引擎的各种工作。</li>
<li>平台层：处理各种平台的工作。</li>
</ol>
<h2 id="挑战：用引擎的层次创建一个会动的小人"><a href="#挑战：用引擎的层次创建一个会动的小人" class="headerlink" title="挑战：用引擎的层次创建一个会动的小人"></a>挑战：用引擎的层次创建一个会动的小人</h2><ol>
<li>资源的导入：<br>由于我们常用的文件有很多格式如fbx、glb等。如果在引擎中使用各种格式的文件的话，会徒增非常多的工作量。所以我们在导入文件的时候会进行一次转化，将之转化为高效的引擎资源。从而便于用户操作，并提高性能。存入的资产有很多类型，并且在引擎中会被多次使用，且资源之间有很多关联，所以我们会用一个GUID来标记资源，便于资源管理。</li>
<li>资源层的工作：<br> 管理所有的资源。</li>
<li>功能层的工作：<br> 通过ticks来实现每一帧的工作。一般来说ticks分为逻辑和渲染两个部分。逻辑部分实现物理、游戏逻辑等工作，而渲染部分则负责画面效果的绘制。</li>
<li>核心层的工作：<br>为各种数学运算提供支持、为上层提供可操作的数据结构、内存分配管理（为了更高的效率）。质量要求最高的一层。</li>
<li>平台层：将各个平台使用的不同的api进行封装，使得引擎可以在不同平台进行工作。</li>
<li>工具层：提供GUI来让用户来进行编辑（包括：逻辑、动画、场景、资源等）。</li>
</ol>
<h2 id="为什么引擎要分层："><a href="#为什么引擎要分层：" class="headerlink" title="为什么引擎要分层："></a>为什么引擎要分层：</h2><p><strong>为了降低复杂度：</strong><br><strong>每一层负责每一层的工作，封装各个部分后可以让人不需要在意底层的工作内容。</strong></p>
<p>同时越是底层的东西越不要去更改他，分层结构的特点就是越往上越灵活，越往下越稳定。在做任何事的时候都需要考虑这部分工作处于哪一层。同时底层不允许去调用上层的api。（最重要的思想）</p>
<p>课程引擎在哪找？等我去找找。PILOT。</p>
<p>找到了：<br><a target="_blank" rel="noopener" href="https://github.com/BoomingTech/Piccolo">https://github.com/BoomingTech/Piccolo</a></p>
<h1 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h1><h2 id="gameplay中的各个组成元素"><a href="#gameplay中的各个组成元素" class="headerlink" title="gameplay中的各个组成元素"></a>gameplay中的各个组成元素</h2><ol>
<li>动态物</li>
<li>静态物</li>
<li>地形系统</li>
<li>天空</li>
<li>其他</li>
</ol>
<h3 id="游戏对象："><a href="#游戏对象：" class="headerlink" title="游戏对象："></a>游戏对象：</h3><p>上述元素，在引擎中，我们会将他们抽象为game object。通过Game Object，我们就可以制作游戏了。</p>
<p>一般来说，一个Game Object只需要属性和行为，便可以用来描述所有东西。落实到各个物体中，我们便可以将其抽象成一个类对象。</p>
<p><img src="/images/2023-11-16-17-16-51.png" alt></p>
<p>上图无人机类的设计中，我们可以考虑使用继承的思路来进行game object的设计。但是这种方法虽然简单易懂，但是随着我们的物体越来越多，物体间的关系却越来越模糊（水陆两栖坦克到底继承自坦克还是船呢？）如何解决这种问题？现代引擎使用的思路是使用组件的方式来进行设计。</p>
<p><img src="/images/2023-11-16-17-19-18.png" alt></p>
<p>将各个功能对应到对应的组件，每个game object则是由组件组成的。例如一个无人机由位置、机身、机翅、摄像头等组件组成。</p>
<h2 id="运动"><a href="#运动" class="headerlink" title="运动:"></a>运动:</h2><p>有了游戏对象，我们可以设置好游戏的场景和游戏对象。但是如何让他们动起来呢？每一帧让每一个game object来进行他们的工作。只要帧数足够高，场景便运动了起来。但是顺序工作的工作效率是非常低的。为了达到更高的效率，tick系统中，我们会通过流水线的方式来进行优化。</p>
<h2 id="交互："><a href="#交互：" class="headerlink" title="交互："></a>交互：</h2><ol>
<li>Hardcode：做线性遍历，进行判断。</li>
<li>Events：给目标物体添加event，让其在其tick中进行处理</li>
</ol>
<p>两者的区别在于events进行了解耦合，变得简单且干净（嗯呗）。</p>
<h2 id="管理物体"><a href="#管理物体" class="headerlink" title="管理物体:"></a>管理物体:</h2><p>每个game object中会设置对应的id（区别于资源的GUID）。</p>
<h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><ol>
<li>不管理：对所有物体进行位置的判断。</li>
<li>空间划分：哈希和八叉树以及其他的分割方式。</li>
</ol>
<h2 id="物体间的绑定和事件系统"><a href="#物体间的绑定和事件系统" class="headerlink" title="物体间的绑定和事件系统"></a>物体间的绑定和事件系统</h2><p>物体间是有父子关系的。那么在tick中，我们tick时的操作顺序是什么样的呢？一般是由父物体到子物体。</p>
<p>事件系统我们在上面已经描述过了，这里说一个事件消息系统的问题：产生消息后，物体的执行时机。具体的执行顺序受到很多东西的影响：软件上算法的实现比如是在受到消息后立即执行还是延迟到下一个tick执行；硬件也会影响，比如有多线程的计算设备通过多线程的方式计算会获得不确定的结果等。消息系统的设计也是非常重要的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/11/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/07/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A003/" class="post-title-link" itemprop="url">算法学习03</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-07 10:41:36" itemprop="dateCreated datePublished" datetime="2023-11-07T10:41:36+08:00">2023-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 10:14:40" itemprop="dateModified" datetime="2023-11-16T10:14:40+08:00">2023-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="旧题复习"><a href="#旧题复习" class="headerlink" title="旧题复习"></a>旧题复习</h1><h2 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其总和大于等于target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<p>本题采用思路为双指针的方法来创建一个滑动窗口，定义一个滑动窗口需要的数据包括：头指针、尾指针、元素数量、元素和。</p>
<p>每一次循环需要做的工作是判断是当前元素和是否大于阈值，如果大于的话尾指针向前，总和减去尾指针之前指向的数据。如果小于的话则将头指针向前并将新的元素加入总和中。在此过程中，我们记录每一次超过阈值的数据的滑动窗口元素数量，记录最小数量。完成循环后返回该值即可。</p>
<p>以下为代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> winSize = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=nums.<span class="built_in">size</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                sum-=nums[p];</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">if</span>(winSize&lt;res)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = winSize;</span><br><span class="line">                &#125;</span><br><span class="line">                winSize--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i!=nums.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                winSize++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==INT_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p>给你一个非负整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>原题链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p>
<p>思路：本题可以通过回溯的方法将所有的组合都找到，但是这样做在leetcode上会超时（暴力遍历不可取）。本题目可以采用动态规划的思想,动态规划的本质是将问题拆分成可以解决的小问题，通过小问题递推出大问题的答案。</p>
<p>这个题目要如何分解呢？我们可以这样解读问题：假设一个数组的可以分为两部分，一部分的和等于另外一部分加上target。这是我们对问题的第一次分解。如此，我们还可以继续分解：在数组的一部分和为（target+数组和）/ 2时（部分a - 部分b = 部分a -（总和sum - 部分a）= target ==&gt; 部分a = （总和sum + target）/ 2），有多少种组合。分解到这一步，我们就可以考虑使用dp数组来存储组合数量了，设定dp[j]代表在容量为j下（也就是部分和为a时），有dp[j]种方法。有了dp数组之后，便可以确定递推公式：<strong>dp[j] += dp[j - nums[i]]</strong></p>
<p>由于j本身是数组之中各种组合的和，那么j-当前遍历的数就代表了缺少当前数的状态，一轮nums的遍历之后就是将能够凑到j的数据找到并作为一种结果存入dp数组中。由此可以通过这种方式来进行递推，从而获取结果。<strong>类似于上楼梯问题，每一种情况都是能到达这种情况的其他几种情况的组合的和</strong></p>
<p>由此代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)<span class="comment">//求数组和</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="built_in">abs</span>(target))<span class="comment">//如果和的大小小于目标值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((target + sum) % <span class="number">2</span> == <span class="number">1</span>)<span class="comment">//判断能否获得目标值的和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> bagsize = (target + sum) / <span class="number">2</span>;<span class="comment">//设置背包大小</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(bagsize+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//设置背包</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始情况为1，也就是数组元素值等于目标值时有一种组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = bagsize;j&gt;=nums[i];j--)<span class="comment">//上楼梯的方法统计</span></span><br><span class="line">            &#123;</span><br><span class="line">                 dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagsize];<span class="comment">//返回目标值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/18/games101%E7%AC%94%E8%AE%B022/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/18/games101%E7%AC%94%E8%AE%B022/" class="post-title-link" itemprop="url">games101笔记22</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-09-18 10:09:16 / 修改时间：16:25:53" itemprop="dateCreated datePublished" datetime="2023-09-18T10:09:16+08:00">2023-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第二十二课"><a href="#第二十二课" class="headerlink" title="第二十二课"></a>第二十二课</h1><h2 id="粒子系统："><a href="#粒子系统：" class="headerlink" title="粒子系统："></a>粒子系统：</h2><h3 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h3><p>设置速度场，任意位置x，任意时间t，我们都可以获得该粒子的速度。这就是我们定义的速度场：</p>
<p><img src="/images/2023-09-18-10-38-25.png" alt></p>
<p><img src="/images/2023-09-18-10-38-43.png" alt></p>
<p>要计算一个粒子的位置，我们可以考虑使用迭代的方法，步长就是Δt：</p>
<p><img src="/images/2023-09-18-10-41-44.png" alt></p>
<p>这就是欧拉方法的思路，但是欧拉方法也有一些问题：有误差，如果我们的步长选择过大，那么我们获得的结果就会有误差（而且误差可能会越来越大）。比较简单的解决方法就是减小步长；不稳定，同样是由步长造成的，可以参考下图：</p>
<p><img src="/images/2023-09-18-10-46-28.png" alt></p>
<p>例如我们的速度场是同心圆，那么无论步长取多少，最后的都会变成向外扩张的漩涡，而不是圆周运动。</p>
<p>一切使用数值方法来解微分方程都会有不稳定问题和误差问题。</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol>
<li>中点法：不希望欧拉方法离结果越来越远，我们使用一次步长，然后记录步长工作后的点到出发点的中点，然后使用中点继续算一个步长，以这个为结果：</li>
</ol>
<p><img src="/images/2023-09-18-10-53-53.png" alt></p>
<ol>
<li><p>自适应方法：判断正常一次步长和中点运动1/2步长的位置是否相似，如果相似则使用其结果，如果两者相差较远则继续细分。</p>
</li>
<li><p>隐式欧拉方法：通过结果来进行推导，利用下一步的速度来计算，但是该方法计算开销较大：</p>
<p><img src="/images/2023-09-18-11-29-45.png" alt></p>
</li>
</ol>
<h3 id="如何定义一个方法是不是稳定的"><a href="#如何定义一个方法是不是稳定的" class="headerlink" title="如何定义一个方法是不是稳定的"></a>如何定义一个方法是不是稳定的</h3><p>计算每一步的误差，然后由此获得总误差。然后我们判断其和步长的关系，我们使用阶的方式来进行判断。这里直接给出结论：隐式欧拉方法是1阶，也就是说局部误差为O（h²）的误差，全局为O（h）。O（h）意味着，我减少步长一半，我们的误差也减少一半，几次方意味着误差减少多少倍。</p>
<ol>
<li>龙格库塔方法：使用一个四阶的方法，也称为RK4，具体过程为：</li>
</ol>
<p><img src="/images/2023-09-18-11-36-02.png" alt></p>
<p>推导过程省略（数据分析课程内容）。</p>
<h2 id="刚体模拟："><a href="#刚体模拟：" class="headerlink" title="刚体模拟："></a>刚体模拟：</h2><p>刚体内部会有很多模拟量要考虑，因为刚体是有体积的：</p>
<p><img src="/images/2023-09-18-11-46-52.png" alt></p>
<p>在原本的速度和位置的基础上，还要考虑角速度、角加速度等量。写出上述式子之后，我们可以采用欧拉方法来进行具体的计算。</p>
<h2 id="SPH"><a href="#SPH" class="headerlink" title="SPH"></a>SPH</h2><p>通过粒子的位置来确定速度场，可以通过梯度下降的方式来获得物体。可参考博客文章。</p>
<h2 id="拉格朗日方法"><a href="#拉格朗日方法" class="headerlink" title="拉格朗日方法"></a>拉格朗日方法</h2><p>更改各个点的位置的一种思路：每一个粒子对象都有自己的坐标系，着重于单个粒子对象的位置计算。</p>
<p><img src="/images/2023-09-18-11-56-13.png" alt></p>
<h2 id="欧拉法（粒子系统中的）"><a href="#欧拉法（粒子系统中的）" class="headerlink" title="欧拉法（粒子系统中的）"></a>欧拉法（粒子系统中的）</h2><p>考虑一个网格随着不同的时间是如何变化的，每次计算考虑的是一个网格的信息。</p>
<p><img src="/images/2023-09-18-11-57-17.png" alt></p>
<h2 id="混合方法（MPM）"><a href="#混合方法（MPM）" class="headerlink" title="混合方法（MPM）"></a>混合方法（MPM）</h2><p>考虑上述两个方法：</p>
<p><img src="/images/2023-09-18-11-57-47.png" alt></p>
<p>融化的过程使用欧拉视角，计算完成后将内部粒子信息记录为空间格子信息，然后继续计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">设计模式学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-16 14:23:15" itemprop="dateCreated datePublished" datetime="2023-09-16T14:23:15+08:00">2023-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-11 21:34:21" itemprop="dateModified" datetime="2023-10-11T21:34:21+08:00">2023-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h2><p>本文用于记录学习设计模式的过程。由于专业问题，本专业没有软件工程课程，近段时间在面试的过程中和面试官聊后了解到，大型项目对于设计模式的需求很高，于是便有了这篇文章。本文记录阅读《大话设计模式》（作者：程杰）后学习的相关内容，本质是一篇简单的读书笔记。本文中所有图片来自于《大话设计模式》。</p>
<h2 id="为何需要设计模式？"><a href="#为何需要设计模式？" class="headerlink" title="为何需要设计模式？"></a>为何需要设计模式？</h2><p>让我们编写的程序能够做到易于维护、易于更改、灵活性高、易于扩展、易于复用等。在面对需求更改时能够快速轻松的进行对应程序的修改。优秀的设计模式可以极大的提升程序的开发和维护效率。</p>
<h3 id="设计模式的实现手段"><a href="#设计模式的实现手段" class="headerlink" title="设计模式的实现手段"></a>设计模式的实现手段</h3><p>面向对象的编程思想（封装、继承、多态来降低耦合度）。</p>
<h3 id="面向对象的复习（oop）"><a href="#面向对象的复习（oop）" class="headerlink" title="面向对象的复习（oop）"></a>面向对象的复习（oop）</h3><ol>
<li><p>类与实例：</p>
<p> 对象是一个自包含的实体，用一组可识别的特性和行为来标识。简单来说，就是具有相同的属性和功能的对象的抽象的集合。其中，如果要具体描述一个对象，我们就要通过类来生成一个对象，这个对象就是我们对于该类的一个实例。例如我们有一个Cat类，通过C#中的代码：</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat mimi = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p> 我们就创建了一个名字叫做mimi的猫的实例。</p>
</li>
<li><p>构造方法：</p>
<p> 如果我们希望在创建实例的时候，对对象进行初始化，那么我们就可以编写一个构造方法，假设我们的Cat类中有一个string字段用于存储猫咪的名字，字段名为name。我们就可以编写对应的构造方法：</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> newName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    name = newName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这样，在我们创建实例的时候，就可以直接对猫咪的名字字段进行初始化了。</p>
 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat mimi = <span class="keyword">new</span> Cat(<span class="string">&quot;咪咪&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法重载：</p>
<p>如果我们希望小猫出生后没有具体的名字（可能没有想好名字）的时候可以有一个通用名字，那么我们可以编写新的构造函数。不过我们已经写好了一个构造函数了，要怎么做才能实现一个新的构造函数呢？这里我们可以用到方法重载的思想，一般来说，同名函数在参数不同时会被重载，假设我们没有输入小猫的姓名，那么可能会出现错误（一般来说会调用默认构造函数）。我们只需要添加一个无参数的构造函数：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span>(<span class="params"><span class="built_in">string</span> newName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     name = newName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">     name = <span class="string">&quot;没有名字&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在创建猫咪的对象时，就算没有名字，也可以创建我们需要的对象了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat mimi = <span class="keyword">new</span> Cat();<span class="comment">//这一步过后mimi中的name字段变成了&quot;没有名字&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属性与修饰符:</p>
<p>字段是存储类要满足其设计所需要的数据，字段是与类相关的变量。也就是我们在类中存储的成员变量。一般来说，字段我们都希望其不会被访问到，这样可以提高安全度。但是用户又需要对字段进行读写操作，于是我们提出属性这个概念来实现对对象字段的读写操作。属性中提供了get和set两个方法用于读和写。假设我们的猫咪类中有一个私有字段int，变量名为shoutNums，我们可以设置相应的属性来进行设计：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ShoutNums</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">set</span>&#123;shoutNums = <span class="keyword">value</span>;&#125;<span class="comment">//更改shoutNums值</span></span><br><span class="line">     <span class="keyword">get</span>&#123;<span class="keyword">return</span> shoutNums;&#125;<span class="comment">//读取shoutNums值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以直接通过表达式来对Cat对象中的字段进行更改了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cat mimi = <span class="keyword">new</span> Cat();</span><br><span class="line">mimi.ShoutNums = <span class="number">5</span>;</span><br><span class="line">Consloe.Write(mimi.ShoutNums);</span><br></pre></td></tr></table></figure>
<p>输出结果为5。但是实际改变的改变的是Cat中的字段。</p>
</li>
<li><p>封装：</p>
<p> 每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。优秀的封装可以减少耦合度。</p>
</li>
<li><p>继承:</p>
<p>学习继承最好是记住三句话，如果子类继承于父类，第一、子类拥有父类非private的属性和功能；第二、子类具有自己的属性和功能，即子类可以扩展父类没有的属性和功能；第三、子类还可以以自己的方式实现父类的功能（方法重写）。对于继承，我们会用到一个新的访问修饰词：protected，这种修饰词修饰的对象对子类是完全公开的，但是对其他人不公开。继承的好处是让子类能够更好的扩展。</p>
</li>
<li><p>多态：</p>
<p>主要依靠重写和重载来实现。重载意味着同名函数的不同参数的不同处理方式，上文第三点就是一个粒子。重写就是子类对父类的虚方法的重写。重写还有一些细节：例如最后的对象调用虚函数时，最后实际调用的方法是最末端的子类的对应方法。</p>
</li>
<li><p>重构：</p>
<p>重构是在编写代码后通过更改代码的内部结构而不更改代码的外部行为来改进代码的过程。例如我们有一个动物虚类，我们创建了对应的子类包括猫狗牛羊四种动物，每一种动物都需要写对应的叫声方法。于是我们可以考虑在动物类中提供叫声公共方法，然后创建对应的虚方法，公共方法调用虚方法，虚方法则实现具体的叫声。这样我们在需要更改的时候就不用对所有类进行更改了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">Shout</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;我是：&quot;</span>+getShoutSound();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> virtural <span class="built_in">string</span> <span class="title">getShoutSound</span>()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Cat</span> () : <span class="title">base</span>()</span></span><br><span class="line">     &#123; &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Cat</span> (<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span></span><br><span class="line">     &#123; &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">getShoutSound</span> ()</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;喵&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诸如此类，其他动物也是相同。</p>
</li>
<li><p>抽象类：</p>
<p> 上述代码例子中，动物类完全不需要实例化，为了安全起见，我们可以考虑将其设置为抽象类，在C#中，提供了修饰词abstract。抽象类具有以下几种特性：第一，抽象类不能实例化。第二，抽象方法是必须被子类重写的方法。第三，如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。同时在设计上，抽象类拥有尽可能多的共同代码，拥有尽可能少的数据。</p>
</li>
<li><p>接口：</p>
<p>接口是把隐式公共方法和属性组合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的执行方式。和抽象类的区别是可以一对多，同时抽象类是对类抽象，接口是对行为抽象。</p>
</li>
<li><p>集合：</p>
<p>C#中提供的一些数据结构。类似于c++中STL提供的容器。</p>
</li>
<li><p>泛型：</p>
<p>类似于c++中的模板，泛型是具有占位符（类型参数）的类、结构、接口和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符；类型参数作为其字段的类型和其方法的参数类型出现。使用时要注意不要频繁造成装箱。</p>
</li>
<li><p>委托与事件：</p>
<p>委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程。委托的应用一般在：一个方法使用后，会使得其他对象有所反应，可以通过委托和事件来实现。</p>
</li>
</ol>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>本章节通过计算器程序的案例向我们介绍了面向对象编程写出的程序的意义：</p>
<p><strong>可维护、可复用、可扩展、灵活性较好</strong></p>
<p>通过通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加的灵活，容易修改，并且易于复用。这就是使用设计模式的主要目的。</p>
<p>在案例中，我们将计算器的界面部分和业务逻辑部分分离开来，界面工作交给一个类来进行、业务逻辑（计算器的计算部分）交给另外一个类来进行，这个步骤中就使用到了面向对象编程的封装部分的思想。</p>
<p>之后考虑到业务逻辑类中添加计算方法的步骤，之前写出的业务逻辑类如下：</p>
<p><img src="/images/2023-09-17-18-59-54.png" alt></p>
<p>可以看到上述方法如果要添加计算功能，则需要在GetResult中更改，虽然只是增加了一条switch的分支，但是还是有可能影响到所有的计算方法。于是书中给出了一个解决思路，将计算这个过程抽象出来，具体的计算方法作为其对应的子类，进行实现，一种类对应一种计算：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _numberA = <span class="number">0</span>;<span class="comment">//计算数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">double</span> _numberB = <span class="number">0</span>;<span class="comment">//计算数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> NumberA<span class="comment">//对应属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>  &#123;  <span class="keyword">return</span> _numberA;  &#125;</span><br><span class="line">        <span class="keyword">set</span>  &#123;  _numberA = <span class="keyword">value</span>;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> NumberB<span class="comment">//对应属性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>  &#123;  <span class="keyword">return</span> _numberB;  &#125;</span><br><span class="line">        <span class="keyword">set</span>  &#123;  _numberB = <span class="keyword">value</span>;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">GetResult</span>()<span class="comment">//子类需要实现的计算方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是基于上述父类，我们可以继承实现对应的计算操作类：</p>
<p><img src="/images/2023-09-17-19-07-57.png" alt></p>
<p>然后我们要考虑的就是具体的对象如何实例化，然后使用正确的对象去做正确的操作的问题：</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>书中提出了简单工厂模式，具体的实现思路如下：</p>
<ol>
<li><p>编写简单工厂类：<br><img src="/images/2023-09-17-19-14-42.png" alt></p>
<p>这个简单工厂类中，我们通过对应的输入生成对应的计算类。</p>
</li>
<li><p>有了上述的类，结合前文给出的两种类型的类（运算父类和运算方法类），我们就可以获得简单工程模式了。</p>
</li>
</ol>
<p>在简单工厂模式中，如果我们需要更改某一个操作计算方法，只需要生成对应的操作子类，并在工厂中添加对应判断即可。</p>
<p>其对应到的UML图如下：</p>
<p><img src="/images/2023-09-17-19-21-50.png" alt></p>
<h3 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h3><p>书中在此处着重说明了UML图，UML图的基本用法如下：</p>
<p><img src="/images/2023-09-17-19-25-14.png" alt></p>
<ol>
<li>类使用方框表示，首行为类名称、第二行为特性（字段属性，或者说成员变量）、第三行为对应的操作，如果类名为斜体则代表为抽象类。</li>
<li>接口用一个圆形表示，加上一个圆代表接上了对应的接口。接口的实现类似于类第一行为接口名、第二行为接口方法。</li>
<li>各种类之间的关系表示方法由图中给出包括：依赖关系、组合关系、聚合关系、继承关系、关联关系等。</li>
<li>+表示public、-表示private、#表示protected。</li>
</ol>
<h4 id="各种关系说明"><a href="#各种关系说明" class="headerlink" title="各种关系说明"></a>各种关系说明</h4><ol>
<li>继承关系：如上图中的动物和鸟以及鸟和大雁、鸭、企鹅等关系称之为继承，其从逻辑上从属于某一个类，则可以使用继承关系，继承者可以具有被继承者的一些通用方法和属性（如上图中的有生命和下蛋）。</li>
<li>关联关系：如上图中的企鹅和气候，由于企鹅的行为会依赖于气候，所以企鹅需要知道气候相关的内容，所以这里企鹅会与气候有一个关联关系。代码层面上意味着企鹅类中包含有气候类的实例。</li>
<li>聚合关系：类似于大雁和雁群的关系，雁群众可能有大量的大雁实例，但是大雁中不会包含雁群对象。这就是一种包含的关系，一种弱拥有的关系。</li>
<li>组合关系：是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。例如一只鸟对应了两只翅膀（对应图中的1和2的数字标记）。</li>
<li>依赖关系：一个类中使用到了另外的类，比如图中的动物用到了氧气和水作为其参数。这体现了一种弱相关性。</li>
</ol>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>本章中使用了一个案例，为超市制作一个计算系统，要求有返利、打折等计算方法。一开始我们可以考虑使用简单工厂模式来进行设计：首先创建一个操作类，里面包含三种计算方法类：正常计算、打折计算、返利计算。然后通过工厂类来生成对应的计算对象，从而完成物品价格的计算。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>第二种提出的方法是策略模式，这种模式更加适合做收银、算账等软件。其核心思想是维护一个抽象策略类，选择不同的具体策略（对应的方法子类），选择部分交给一个策略类来进行实现。</p>
<p><img src="/images/2023-09-18-15-36-01.png" alt></p>
<p>根据上述内容，我们可以将工厂模式和策略模式结合。在工厂模式中，我们选择方法需要认识工厂类，通过工厂类提供的静态方法来获取对应的计算方法，但是结合策略模式之后，我们只需要生成对应的方法类对象即可，具体的类选择交给了一个类，用户也只需要使用一个类即可。</p>
<p><img src="/images/2023-09-18-15-41-40.png" alt></p>
<p>可以看到CashContext类用于选择正确的策略，用户只需要生成对应的CashContext对象即可，大大降低了耦合。</p>
<p>我们现在再来看策略模式的定义：</p>
<p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
<h3 id="策略模式和工厂模式的区别"><a href="#策略模式和工厂模式的区别" class="headerlink" title="策略模式和工厂模式的区别"></a>策略模式和工厂模式的区别</h3><p>策略模式主要是为了选择具体的算法对象，而工厂模式主要是为了产生具体的对象（创建合适对象）。因此，策略模式比较适合于算法的选择，而工厂模式则适合大量对象的生产。同时策略对象中的策略是可以相互替换的，但是工厂模式中的工厂类则对应了多个类，这是一种一对多的关系。</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>就一个类而言，应该仅有一个引起它变化的原因[ASD]（开放封闭原则）。一个类如果负责实现多个功能可能会造成修改或是增加一个功能时会使得其他功能产生一定的变化。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]。</p>
<p>在书中提到了俄罗斯方块这个游戏，游戏的底层功能逻辑是不变的，但是gui界面是多变了（手机端、pc端、不同的GUI选择）。所以可以将功能写在一个类中，这样在移植时就可以减少代码量了。</p>
<p>在做某一功能的实现时要多考虑是否利于开发者来进行功能拓展，该方法对于其他功能的影响大不大，基于上述两点，我们可以选择是否要做减少类的功能来遵守单一职责原则。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/13/games101%E7%AC%94%E8%AE%B019-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/13/games101%E7%AC%94%E8%AE%B019-21/" class="post-title-link" itemprop="url">games101笔记19-21</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-13 14:43:43" itemprop="dateCreated datePublished" datetime="2023-09-13T14:43:43+08:00">2023-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-18 16:25:55" itemprop="dateModified" datetime="2023-09-18T16:25:55+08:00">2023-09-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十九课"><a href="#第十九课" class="headerlink" title="第十九课"></a>第十九课</h1><h2 id="相机的成像原理："><a href="#相机的成像原理：" class="headerlink" title="相机的成像原理："></a>相机的成像原理：</h2><p>最早的相机实现过程是通富哦小孔成像的原理来实现的。这种相机称之为针孔相机。</p>
<p><img src="/images/2023-09-13-14-59-58.png" alt></p>
<p>在相机中有一个部件，</p>
<p><img src="/images/2023-09-13-15-04-38.png" alt></p>
<p>传感器用于记录irradiance，也就是收集到的光的能量。其收集方式为：</p>
<p><img src="/images/2023-09-15-09-39-30.png" alt></p>
<p>当然，传感器有方向的接收光源（randiance）目前也有人在研究。</p>
<p>针孔相机：很早就被发现小孔成像原理，时至今日还是可以这个原理来拍照，但是针孔相机拍摄的结果都是清晰的，没有深度可言（没有聚焦以及模糊）。我们之前所说的光线追踪也是这样的效果。</p>
<h3 id="FOV"><a href="#FOV" class="headerlink" title="FOV"></a>FOV</h3><p>小孔成像的视场：</p>
<p><img src="/images/2023-09-15-09-43-31.png" alt></p>
<p>什么因素可以决定视场呢？如上图，我们从上述的图形中，假设我们认为我们的传感器是完全收集到光线的（上图蓝色平面），从两个端点处向小孔连线，然后向外延伸，这样我们就可以获得我们能够看到的视场了。</p>
<p>由上图我们可以获得FOV角度：FOV = 2arctan(h/(2*f))</p>
<p>根据上述结果：我们可以知道，FOV和焦距f和传感器大小h。</p>
<h3 id="Exposure"><a href="#Exposure" class="headerlink" title="Exposure"></a>Exposure</h3><p>曝光度 = 时间*irrandiance</p>
<p>其记录的是一个时间段内接收到的能量。</p>
<h3 id="影响照片亮度的原因"><a href="#影响照片亮度的原因" class="headerlink" title="影响照片亮度的原因"></a>影响照片亮度的原因</h3><ol>
<li>光圈的大小（可由相机控制），控制方式为f数（f-stop）。</li>
<li>快门（shutter speed），控制接触光的时间长短。</li>
<li>感光度（ISO gain），类似一种后期处理，完成光的接收后，我们对收集到的数据进行一个线性变化。</li>
</ol>
<p>各种因素影响的拍摄图片效果：</p>
<p><img src="/images/2023-09-15-10-11-30.png" alt></p>
<h4 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h4><p>线性变化（ISO200就是ISO100的两倍，当然这个是系数）。过大会产生噪声。</p>
<p><img src="/images/2023-09-15-10-20-29.png" alt></p>
<h4 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h4><p>用来描述光圈的大小的数称之为f数。一般写法为FN或者F/N。其中n就是我们的f数。简单来说，f数就是光圈的直径的-1次方（这是简单理解，之后会详细解释）。</p>
<p><img src="/images/2023-09-15-14-56-00.png" alt></p>
<p>通过调节光圈可以直接控制有多少光进入传感器中，从而获得上述效果。</p>
<h4 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h4><p>快门可以起到调节曝光度的作用，同时会有几个情况：</p>
<ol>
<li>快门本身打开需要花费时间</li>
<li>会有运动模糊（在快门工作的时间内物体运动产生的）。</li>
</ol>
<p>如果我们把快门的时间加快，我们可以减少运动模糊，但是运动模糊一般也不是坏事，有运动模糊可以制造一种速度感。（在unity中有一些特别的shader来做卡通运动模糊效果，非常酷炫）。</p>
<p>我们可以在时间上进行采样，可以达到反走样的效果。类似于我们在走样2d图像上进行模糊或者插值。</p>
<p>如果我们的快门速度过快（电子控制，任何时候同步打开），可能会出现问题（Rolling shutter问题）会对高速物体的成像上有扭曲。</p>
<p><img src="/images/2023-09-15-15-10-44.png" alt></p>
<p>因为不同时间上记录的光不同，从而造成了扭曲。</p>
<h3 id="不同参数的同效果实现："><a href="#不同参数的同效果实现：" class="headerlink" title="不同参数的同效果实现："></a>不同参数的同效果实现：</h3><p><img src="/images/2023-09-15-15-12-07.png" alt></p>
<p>上图表让我们知道一些不同参数的不同值可以获得类似的效果（不完全相同，但是非常相似）。F值会对景深造成影响，快门会对运动模糊造成影响。</p>
<h3 id="高速摄影"><a href="#高速摄影" class="headerlink" title="高速摄影"></a>高速摄影</h3><p><img src="/images/2023-09-15-15-14-08.png" alt></p>
<p>本质上是每一秒都拍很多照片，说明快门的速度非常快，同时需要保持更大的光圈。</p>
<p>eg：</p>
<p><img src="/images/2023-09-15-15-14-53.png" alt></p>
<h3 id="超低速摄影："><a href="#超低速摄影：" class="headerlink" title="超低速摄影："></a>超低速摄影：</h3><p><img src="/images/2023-09-15-15-15-13.png" alt></p>
<p>用小光圈加慢快门来实现，可以达到很多好看的效果（曝光时间非常，物体的所有剧烈运动都记录了下来）。</p>
<p>eg:</p>
<p><img src="/images/2023-09-15-15-16-11.png" alt></p>
<h3 id="棱镜"><a href="#棱镜" class="headerlink" title="棱镜"></a>棱镜</h3><p>对于一般相机来说，镜头都是非常复杂的，一般来说的是由多个棱镜来做镜头的：</p>
<p><img src="/images/2023-09-15-15-38-43.png" alt></p>
<p>我们研究的透镜是理想化的薄透镜，平行光打入会聚集到一个点。</p>
<p><img src="/images/2023-09-15-15-39-46.png" alt></p>
<p>同时点光源反向传播的化可以被转化为平行光。假设一个透镜镜可以改变焦距（一般来说一个透镜不能改变的，但是现代相机使用透镜组来实现了这个效果）。</p>
<p>透镜满足的基本物理规律：</p>
<p><img src="/images/2023-09-15-15-41-19.png" alt></p>
<p>上图左边的光，通过棱镜之后会有上述规律：焦距的倒数=相距（成像到棱镜的距离）的倒数+物距（物体到棱镜的距离）的倒数。固定的焦距，如果改变物距，相距也要改。</p>
<p>推导过程：</p>
<p><img src="/images/2023-09-15-15-49-54.png" alt></p>
<p>上图获得两组相似三角形，</p>
<p>然后通过两个等式解方程：</p>
<p><img src="/images/2023-09-15-15-50-45.png" alt></p>
<p>高中物理(不多说了 虽然我没有上过高中，乐)。</p>
<p>光圈的原理（场景深度的解释）：</p>
<ol>
<li>CoC（Circle of Confusion），物体如果不在聚焦平面上，那么通过上述公式进行相似三角形的推导，我们可以知道其对应成像位置不在感光平面上，只有继续传播的光线会被收集到。假设原本的物体为一个点，经过上述过程，就会成像为一个圆。eg：</li>
</ol>
<p><img src="/images/2023-09-15-16-02-15.png" alt></p>
<p>其大小的计算方式为：首先根据图片易得底为A的等腰三角形和底为C的等腰三角形相似，所以C/A = d’/Zi。d’的大小为Zi-Zs的绝对值，由此可以计算出我们成像的C的大小，一般其余值是不变的，C变化A也变化。由此我们可知C的大小是和A（光圈大小）成正比的。</p>
<p>eg：</p>
<p><img src="/images/2023-09-15-16-08-01.png" alt></p>
<p>f为1.4时（大光圈），coc较大，比较模糊。f为22时（小光圈），coc较小，比较清晰。</p>
<ol>
<li>f的明确定义是：焦距/光圈的直径（也就是说还和焦距有关系）。一些不同相机的f：<br><img src="/images/2023-09-15-16-10-02.png" alt></li>
</ol>
<p>回顾上述两点，我们会发现CoC的表达式可以为：</p>
<p><img src="/images/2023-09-15-16-10-47.png" alt></p>
<p>所以光圈大小会实际影响CoC(和N为反比关系)。</p>
<h3 id="模拟薄透镜的渲染方式："><a href="#模拟薄透镜的渲染方式：" class="headerlink" title="模拟薄透镜的渲染方式："></a>模拟薄透镜的渲染方式：</h3><p><img src="/images/2023-09-15-16-15-14.png" alt></p>
<p>具体实现原理：我们首先要定义场景物体、感光平面、透镜属性(焦距和光圈大小)、物距。</p>
<p><img src="/images/2023-09-15-16-17-18.png" alt></p>
<p>如上图，我们进行反向追踪，从感光平面发出射线找到其从x’到x’’’的位置，这样我们就知道物体光会怎样显示在感光平面上了，我们就可以依据这个原理来进行渲染，从而达到模糊的效果。</p>
<p><strong>景深</strong>：</p>
<p><img src="/images/2023-09-15-16-22-47.png" alt></p>
<p>我们使用大小光圈会影响这个模糊的范围，我们研究光圈就可以获得景深。</p>
<p><img src="/images/2023-09-15-16-26-29.png" alt></p>
<p>左边为景深，我们可以通过透镜将其对应到右边，获得一个成像平面的深度。这两个部分我们就称之为景深。</p>
<p><img src="/images/2023-09-15-16-33-50.png" alt></p>
<p>在成像平面附近，如果coc的大小是小于像素大小的，我们则称之为锐利的，否则模糊。这就是渲染时产生景深的原理。</p>
<h1 id="第二十课"><a href="#第二十课" class="headerlink" title="第二十课"></a>第二十课</h1><h2 id="光场"><a href="#光场" class="headerlink" title="光场"></a>光场</h2><p>我们是如何看到这个世界的？</p>
<p><img src="/images/2023-09-16-09-20-09.png" alt></p>
<p>如果我们将上述情况中加一个幕布，显示的就是我们之前看到的画面：</p>
<p><img src="/images/2023-09-16-09-20-50.png" alt></p>
<p>这就是vr的原理。这样的应用已经在科幻片中进行了应用。</p>
<p>为了描述人看到的东西，我们提出全光函数。</p>
<h3 id="全光函数"><a href="#全光函数" class="headerlink" title="全光函数"></a>全光函数</h3><p><img src="/images/2023-09-16-09-24-00.png" alt></p>
<p>假设我们在一个场景中，同时四面八法固定位置，我们向四周看，可以通过极坐标来表示。同时，我们在方向的基础上再添加一个颜色变量（波长），就可以表示我们看到的方向和颜色了。如果还有播放的需求，我们可以添加时间变量。如果我们的观察者是可以移动的，那么我们就可以使用空间坐标来表示观察者的位置，这样就可以表示：我们在任何位置，向任何方向，任何时刻看到的东西都是不同的。对此我们可以写出下列七维函数：</p>
<p><img src="/images/2023-09-16-09-28-21.png" alt></p>
<p>整个世界都可以用这个方法来表示。</p>
<h3 id="定义光场"><a href="#定义光场" class="headerlink" title="定义光场"></a>定义光场</h3><p>定义光线：</p>
<p><img src="/images/2023-09-16-09-37-03.png" alt></p>
<p>光线的定义有多种，上述定义方式为方向加起始点。我们也可以通过两个点来进行定义。</p>
<p>将物体放入一个包围盒中，我们将包围盒上任意部分发射的光作为我们可以看到物体的光，物体本身则作为黑盒，对于光照信息的接收则只靠包围盒。</p>
<p><img src="/images/2023-09-16-10-20-09.png" alt></p>
<p>在3d场景中，3d物体的表面可以用两个数据来表示（uv展开），由此可以用两个数来表示位置，同时方向也可以用两个数来表示。</p>
<p><img src="/images/2023-09-16-10-24-30.png" alt></p>
<p>在任何一个位置，我们从任何一个方向去看，都可以知道看到的光是什么（通过上述方法，直接查询光场中存储的值）。但是我们作为观测者是不会在意他是几何还是幕布的，我们可以将场景中的光线记录在平面上（上述黑盒）。</p>
<p><img src="/images/2023-09-16-10-28-41.png" alt></p>
<p>（有个前提是观察点在包围盒外面）</p>
<p>实现上述的功能，我们的幕布需要两个参数（2d场景中）， 第一个是方向，第二个是起始点（3d场景中则是4个参数，两个表示方向，两个表示位置）。</p>
<p><img src="/images/2023-09-16-10-33-57.png" alt></p>
<p>同时还有另外一种表示方法，使用两个平面（相互平行），获取两个平面上的两个起始点，然后来确定方向。这种方法也是使用两个参数（3d场景四个参数，也就是两个位置参数）。</p>
<p><img src="/images/2023-09-16-10-37-20.png" alt></p>
<p>常用两个平面的数据（s，t和u，v）。用两个两个平面来定义所有的射出光线。<br>两个平面的观察效果如下：</p>
<p><img src="/images/2023-09-16-10-41-45.png" alt></p>
<p>从uv到st代表我们从各个角度看观察对象。从st向uv看则代表我们从各个角度观察一个部分的细节。</p>
<p>另一种解决方法：</p>
<p><img src="/images/2023-09-16-10-47-19.png" alt></p>
<p>类似于昆虫的复眼，每个像素我们利用透镜将不同方向的光记录在不同的感光元件上，这样就可以通过访问各个感光元件来获得各个方向的光线。利用这个原理，我们可以制作出光场照相机：</p>
<p><img src="/images/2023-09-16-10-49-41.png" alt></p>
<p>其原理就是我们的微透镜原理（将像素变为透镜，然后记录各个方向的光源）。其优点是可以实现后期聚焦，可以让我们动态调节聚焦对象。</p>
<p>具体功能效果：</p>
<p><img src="/images/2023-09-16-10-52-18.png" alt></p>
<p>聚焦改变：</p>

<p>聚焦向近处拉近：</p>
<p><img src="/images/2023-09-16-10-53-27.png" alt></p>
<p>原理：<br><img src="/images/2023-09-16-10-53-47.png" alt></p>
<p>右图透镜原本是各个像素，但是如果我们将其使用透镜进行分割，让不同方向的光分散在不同的数字感光元件上，由此每个像素就可以记录所有方向的光线。这样，我们就记录了拍摄区域的光场信息。</p>
<p>光场照相机如何还原某个方向的图片呢？我们只需要每一个透镜都选择同一方向的光线结果，就可以获得原始照片了。</p>
<p><img src="/images/2023-09-16-10-57-34.png" alt></p>
<p>缺点：成本高，微透镜的实现难度高，如果落实到CG上，其开销更大。</p>
<h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>可见光的波长在400到700。只有在这个范围内，我们才能够看到光。</p>
<p><img src="/images/2023-09-16-11-11-22.png" alt></p>
<h3 id="SPD（谱功率密度）"><a href="#SPD（谱功率密度）" class="headerlink" title="SPD（谱功率密度）"></a>SPD（谱功率密度）</h3><p>我们可以通过SPD来描述任何一个光在对应波长的分布是多少。eg:</p>
<p><img src="/images/2023-09-16-11-12-50.png" alt></p>
<p>阳光的分布主要在700附近，蓝天则在500左右。</p>
<p>SPD的线性性质：</p>
<p><img src="/images/2023-09-16-11-14-14.png" alt></p>
<p>假设有一个物体，用两个不同的光来照射他，其SPD结果就是两个光照SPD的和。</p>
<p>所以颜色到底是什么？颜色是人类的感知，与人有关，和实际光的分布没有过大的关系。</p>
<p><img src="/images/2023-09-16-11-16-14.png" alt></p>
<p>瞳孔就是光圈、晶状体就是透镜、视网膜就是感光元件。人眼就是一个相机。视网膜上有感光细胞：</p>
<p><img src="/images/2023-09-16-11-17-38.png" alt></p>
<p>感光细胞分两种：一种是视杆细胞（用于感知光强，其结果是灰度图），一种是视锥细胞（数量少一些，可以用来感知颜色）。我们研究颜色就需要研究视锥细胞，视锥细胞内部又分为三类，分为S、M、L三类细胞。三种细胞对三种类型的波长响应各不相同:</p>
<p><img src="/images/2023-09-16-11-19-57.png" alt></p>
<p>并且其数量分布也不同:</p>
<p><img src="/images/2023-09-16-11-21-34.png" alt></p>
<p>其分布数量因人而异，所以每个人看到的同样光线都是不同的。</p>
<p>结论就是，我们人类看到的不是颜色，而是S、M、L三个数积分出来的结果。</p>
<h3 id="同色异谱"><a href="#同色异谱" class="headerlink" title="同色异谱"></a>同色异谱</h3><p>我们描述一种颜色可以用不同的SPD来进行描述：</p>
<p><img src="/images/2023-09-16-11-27-20.png" alt></p>
<p>这就是同色异谱。这样给定我们一个颜色，我们可以用户不同的颜色去描述它。我们常用的方法是RGB来进行混合（红绿蓝三种眼色来混合）。</p>
<p><img src="/images/2023-09-16-11-28-36.png" alt></p>
<p>颜色要如何去混合呢？</p>
<p><img src="/images/2023-09-16-11-39-01.png" alt></p>
<p>通过两种夜色的对比，调解RGB的光强，然后直到颜色和目标颜色相似为止。</p>
<p><strong>色彩空间：不同的颜色定义方式。</strong></p>
<p><strong>色域：通过不同的定义方式（不同颜色空间）所有能够表示的颜色。如rgb、xyz等方法定义出的所有的颜色。</strong></p>
<p>一些颜色空间：RGB、XYZ、HSV（色调（具体颜色）、饱和度（是否接近白色）、亮度（是否接近黑色））、LAB（三对轴，每一个轴上是一对互补色，黑白、黄蓝、绿红）、CMYK（蓝绿、品红、黄色、黑色，通过这几种颜色的混合可以获得不同的颜色，所有颜色混合结果是黑色）。</p>
<h1 id="第二十一课"><a href="#第二十一课" class="headerlink" title="第二十一课"></a>第二十一课</h1><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>有了物体之后，我们要开始关心一下怎么让场景中的物体动起来了。</p>
<h3 id="计算机动画"><a href="#计算机动画" class="headerlink" title="计算机动画"></a>计算机动画</h3><p>让物体变成活的，早期动画是连续的绘制的图片播放。在图形学中，我们可以将其作为几何的拓展。一般来说，电影在24帧左右、电视在30帧左右、虚拟现实眼镜在90帧左右。</p>
<h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>优秀的艺术家绘制关键帧，然后其助手负责补足中间的帧：</p>
<p><img src="/images/2023-09-17-16-10-54.png" alt></p>
<p>几种插值的方法：</p>
<ol>
<li>线性插值：<br><img src="/images/2023-09-17-16-13-20.png" alt></li>
<li>平滑：<br><img src="/images/2023-09-17-16-24-21.png" alt></li>
</ol>
<h3 id="物理模拟"><a href="#物理模拟" class="headerlink" title="物理模拟"></a>物理模拟</h3><p>最简单的物理模拟：</p>
<p>F = ma</p>
<p>通过牛顿定律来计算物体的位置或者形状的变化。</p>
<p>eg：<br><img src="/images/2023-09-17-16-26-11.png" alt></p>
<p>抛物线的实现。</p>
<p>同时还有衣物、流体等的模拟。只需要建立正确的物理模型，通过解方程就可以获得具体的物理效果了。</p>
<h4 id="经典的物理模拟系统：质点弹簧系统"><a href="#经典的物理模拟系统：质点弹簧系统" class="headerlink" title="经典的物理模拟系统：质点弹簧系统"></a>经典的物理模拟系统：质点弹簧系统</h4><p>应用：弹簧绳、头发、布料。</p>
<p>原理说明：<br>一个弹簧左右连接两个质点（理想弹簧没有长度，拉开多长具有多大的力）。</p>
<p><img src="/images/2023-09-17-16-34-30.png" alt></p>
<p>b-a是一个向量结果，我们由此可以通过一个劲度系数Ks来求出a到b方向的力。方向相反为a-b。</p>
<p>但是一般来说弹簧是有长度的。我们分析的时候只需要考虑长度就可以了，具体来说就是在上述公式的基础上求出变化的长度，例如我们有一个初始长度l，ab之间的距离为b-a，则有下述公式：</p>
<p><img src="/images/2023-09-17-16-47-28.png" alt></p>
<p>也就是方向归一化之后通过减去初始长度来判断实际变化的长度，从而算出收到的弹力。</p>
<p>提一嘴：一般来说x’为速度，x’’为加速度（距离的求导和二阶导）。然后我们来考虑弹簧内部的摩擦力：</p>
<p><img src="/images/2023-09-17-16-56-55.png" alt></p>
<p>fb收到的阻尼力可以通过b的速度-a的速度点乘b到a的方向，这样我们可以获得相对速度到ba方向上的投影大小。但是我们考虑到一些运动是不会造成内部摩擦力的（例如圆周运动），所以获得投影大小后和判断在ba方向上的影响力（比如圆周的情况，90度则为0了）。（这里公式没有考虑初始长度）。</p>
<p>有了一个弹簧的分析思路后，我们可以将其用来模拟布料等效果：</p>
<p><img src="/images/2023-09-17-17-03-14.png" alt></p>
<p>但是其中也有不合理的地方，例如我们拉扯对角线，这样会导致布变为一条线。</p>
<p>但是我们可以通过更改内部结构来实现具体效果：</p>
<p><img src="/images/2023-09-17-17-05-51.png" alt></p>
<p>这样再对对应的对角线进行拉取不会造成上述问题了（因为内部弹簧的力将其抵消了）。于是我们将两个方向都添加弹簧：</p>
<p><img src="/images/2023-09-17-17-07-00.png" alt></p>
<p>但是就算经过这些处理还是会有一些问题，例如我们将布料对折，内部弹簧是不会受到力的。这不符合布料的性质，于是我们可以进行如下弹簧的添加操作：</p>
<p><img src="/images/2023-09-17-17-08-34.png" alt></p>
<p>经过这种方式，我们可以使布料折叠时产生想对应的弹力了。</p>
<p>其他的布料模拟方法：FEM（有限元分析法），模拟了力之间的传导作用，这个传导过程是一个扩散的过程。这个过程的模拟可以考虑使用FEM方法，虽然难写，但是是从另一个角度来进行建模。</p>
<h4 id="经典的物理模拟系统：粒子系统"><a href="#经典的物理模拟系统：粒子系统" class="headerlink" title="经典的物理模拟系统：粒子系统"></a>经典的物理模拟系统：粒子系统</h4><p><img src="/images/2023-09-17-17-12-27.png" alt></p>
<p>我们将物体一个一个的建模出来，然后通过一些统一的方式对这些粒子进行控制。粒子系统的应用：流体模拟（离散化连续空间中的流体进行模拟）、头发、动物群（ODE）、分子运动模拟、人群模拟。</p>
<p>可以参考本博客的SPH相关文章。</p>
<p>注：模拟只模拟物体的位置、力等物理信息。渲染不参与这个过程。</p>
<h3 id="运动学"><a href="#运动学" class="headerlink" title="运动学"></a>运动学</h3><p>图形学中，运动学分为两个方面：正运动学和逆运动学。骨骼系统的实现一般会较多的应用到运动学。</p>
<h4 id="正向运动学："><a href="#正向运动学：" class="headerlink" title="正向运动学："></a>正向运动学：</h4><p><img src="/images/2023-09-17-17-33-42.png" alt></p>
<p>通过一个确定的物体的起始点，逐步确定与其连接的关节，就可以求出物体实际的定位。</p>
<h4 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h4><p>正向运动学实现容易，但是有一些不好的地方，大多数人是不考虑具体实现的，使用骨骼时是直接拖动目标位置来进行设计的。所以我们可以考虑逆运动学：</p>
<p><img src="/images/2023-09-17-17-35-42.png" alt></p>
<p>我们知道起始点，但是我们输入的数据是非起始点的节点位置，我们需要反向求其剩余结果。逆运动学有一个不好的地方就是结果不唯一，难以求出具体的结果。</p>
<h3 id="Rigging（对于某种形状的控制）"><a href="#Rigging（对于某种形状的控制）" class="headerlink" title="Rigging（对于某种形状的控制）"></a>Rigging（对于某种形状的控制）</h3><p>蒙皮效果，就是让我们的网格模型能够合适的进行控制（尤其是人物一类的模型）。</p>
<h3 id="Montion-Capture"><a href="#Montion-Capture" class="headerlink" title="Montion Capture"></a>Montion Capture</h3><p>动作捕捉，我们希望真实的人物的动作映射到模型上，我们就可以使用动作捕捉：</p>
<p><img src="/images/2023-09-17-17-45-02.png" alt></p>
<p>卡普空的街霸6中就使用了很多动捕。</p>
<p>但是动捕也有很多问题：准备阶段复杂、相对写实难以实现卡通动作效果、捕捉条件有限制时难以捕捉到所有数据（高成本下可以有一定程度的解决）。</p>
<p>目前运用最广泛的动作捕捉方法是光学上的方法。</p>
<p><img src="/images/2023-09-17-17-48-31.png" alt></p>
<h2 id="整个CG动画、电影的实现过程："><a href="#整个CG动画、电影的实现过程：" class="headerlink" title="整个CG动画、电影的实现过程："></a>整个CG动画、电影的实现过程：</h2><p><img src="/images/2023-09-17-17-52-10.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/08/games101%E7%AC%94%E8%AE%B016-18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/08/games101%E7%AC%94%E8%AE%B016-18/" class="post-title-link" itemprop="url">games101笔记16-18</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-08 09:20:24" itemprop="dateCreated datePublished" datetime="2023-09-08T09:20:24+08:00">2023-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-13 15:01:07" itemprop="dateModified" datetime="2023-09-13T15:01:07+08:00">2023-09-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十六课"><a href="#第十六课" class="headerlink" title="第十六课"></a>第十六课</h1><p>回顾  渲染方程：观测到的光 = 物体自发光 + 各个方向来的光线的积分（包括光源和其他物体的反射）。</p>
<h2 id="蒙特卡洛积分："><a href="#蒙特卡洛积分：" class="headerlink" title="蒙特卡洛积分："></a>蒙特卡洛积分：</h2><p>黎曼积分：求长方形宽趋于0的极限来求不定积分。</p>
<p>蒙特卡洛积分的原理：在定积分的范围中进行采样，采样内容为不定积分的被积函数值，用该值作为高，以b-a为宽计算长方形的面积。多次采样后，获得多个结果在计算其平均获得不定积分的解。</p>
<p>使用蒙特卡洛积分的过程：</p>
<p>不定积分：</p>
<p><img src="/images/2023-09-08-09-43-48.png" alt></p>
<p>概率密度函数：</p>
<p><img src="/images/2023-09-08-09-44-02.png" alt></p>
<p>计算过程：<br>假设我们的采样是等可能的采样</p>
<p><img src="/images/2023-09-08-09-51-58.png" alt></p>
<p>我们通过均匀采样的方式采集N次。f(Xi)为高度，b-a为宽度。再求平均，就可以获得我们的对于积分结果的一个估计。</p>
<p>也就是说，我们的计算结果如下：</p>
<p><img src="/images/2023-09-08-09-52-59.png" alt></p>
<p>但是当我们的随机变量的采样不是平均采样的方法呢？我们可以直接使用PDF的值来进行计算：</p>
<p><img src="/images/2023-09-08-10-01-39.png" alt></p>
<p>同时根据上述式子，N值取得越大，越准确。同时其积分域已经在p(Xi)中表示了，比较方便。</p>
<h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>使用辐射度量学的思路来进行光线追踪，我们需要解渲染方程：</p>
<p><img src="/images/2023-09-08-10-21-52.png" alt></p>
<p>我们解决积分部分使用的就是蒙特卡洛方程。我们首先考虑一个点的直接光照：</p>
<p><img src="/images/2023-09-08-10-29-17.png" alt></p>
<p>我们的光源（light）是一个面光源，半球是各个光线的射入方向。</p>
<p>抛去自发光部分：</p>
<p><img src="/images/2023-09-08-10-31-40.png" alt></p>
<p>我们可以使用蒙特卡洛积分的方法，首先从各个方向进行采样（ωi）,所以pdf是对各个射入方向的采样，以下给出一个常用的采样方法：</p>
<p><img src="/images/2023-09-08-10-34-15.png" alt></p>
<p>而我们的积分是上述积分的被积函数部分：</p>
<p><img src="/images/2023-09-08-10-34-50.png" alt></p>
<p>经过变换，我们的积分结果可以近似的得到：</p>
<p><img src="/images/2023-09-08-10-36-16.png" alt></p>
<p>带入对应的数据即可解出结果。但是我们的计算不止是直接光照，还包括间接光照。</p>
<p><img src="/images/2023-09-08-10-44-34.png" alt></p>
<p>例如我们要在P点求取Q点的反射光，我们的思路就是将P点设为一个视点，然后求取Q的发出的直接光照。我们可以通过递归的方式来实现，伪代码：</p>
<p><img src="/images/2023-09-08-10-46-10.png" alt></p>
<p>递归的终止条件是查找的对象受到的光只有光源直射光。</p>
<p>但是这样不能解决问题，原因有两个：</p>
<ol>
<li>光线数量过多，反射次数越多，计算光线越多。只有在我们做蒙特卡洛积分中的N为1时，才不会出现爆炸的现象（这就是路径追逐），如果N不为1，则是分布式光线追踪。<br>路径追踪：</li>
</ol>
<p><img src="/images/2023-09-08-10-53-29.png" alt></p>
<p>对于每一个像素，我们要获得一个光线的值，可以均匀的取N个不同的位置，然后从视点发射出N条光线，然后这个光线会碰到物体或者是光源，如果时光源直接计算其结果，如果时物体，则开始计算其反射（追踪路径，其中蒙特卡洛积分只选取一个方向的射线）。然后求平均，这样就不会出现上述的光线数量爆炸的问题了。伪代码：</p>
<p><img src="/images/2023-09-08-11-01-43.png" alt></p>
<ol>
<li>使用上述方法，shade函数是递归的，这个算法可能永远不会停止，如果我们给他进行反射次数的限制，但是真实情况下光线本身就会弹射无数次，如过直接停止，可能会造成能量的损失。解决方法是使用RR的思想（俄罗斯轮盘赌，Russian Roulett）。我们用这个方法来设置一个概率，让光线停止追踪。假设我们积分的结果是Lo，然后我们定义一个概率P，我们以这个概率发射射线，以1-P的概率不发射射线。然后我们将结果Lo除以P。</li>
</ol>
<p><img src="/images/2023-09-08-11-16-15.png" alt></p>
<p>这个过程是一个计算期望的过程（结果是正确结果的近似，会有噪声产生）。</p>
<p>具体代码：</p>
<p><img src="/images/2023-09-08-11-17-09.png" alt></p>
<p>多出的部分就是使用随机数来进行判定是否需要发射射线。以及除以概率来求取期望的过程。</p>
<h2 id="路径追踪的优化"><a href="#路径追踪的优化" class="headerlink" title="路径追踪的优化"></a>路径追踪的优化</h2><p>需要高效的计算可能获得的结果噪声过多，需要好的效果开销较大。原因是如果光源较小，我们随机选取的光线可能不会打到光源，这样我们只能随机选取更多的光线。</p>
<p><img src="/images/2023-09-08-11-21-40.png" alt></p>
<p>所以，我们要跟换一下PDF，选择更好的采样方法。具体来说就是我们直接在光源上进行采样。</p>
<p>实现原理：</p>
<p>我们将光源当作一个二维的面，我们只需要针对光源方向进行取样，但是光源上是一个面积，蒙特卡洛积分则是使用立体角来进行采样，我们需要考虑一种办法能够让我们继续使用到蒙特卡洛积分。</p>
<p><img src="/images/2023-09-08-11-27-52.png" alt></p>
<p>我们可以通过将光源的面投影到半球体上，这样我们就可以通过投影的面积来进行立体角的计算了（妙）。也就是说，我们将立体角拆分成了映射面积*cos/半径平方（参考前文的立体角定义）。</p>
<p><img src="/images/2023-09-08-11-32-04.png" alt></p>
<p>更改后重写的渲染方程为：</p>
<p><img src="/images/2023-09-08-11-33-38.png" alt></p>
<p>dA就是对光源面积的积分（微积分简单的变量替换）。</p>
<p>于是我们的shade算法就可以进行更改和优化了，对于直接光照，我们采用对光源面积积分的方式采样计算，对于反射物体，我们还是使用立体角的方式进行采样计算。</p>
<p><img src="/images/2023-09-08-11-41-40.png" alt></p>
<p>最后还有一个小问题：我们对直接光源进行采样，可能会出现一些问题。因为我们采样光源时没有考虑是否有物体遮挡，其实这个过程我们只需要做一个向量的判定即可。</p>
<p>对于路径追踪，点光源的处理非常麻烦，建议做成很小的有面积的光源。</p>
<h1 id="第十八课"><a href="#第十八课" class="headerlink" title="第十八课"></a>第十八课</h1><h2 id="材质与外观"><a href="#材质与外观" class="headerlink" title="材质与外观"></a>材质与外观</h2><p>在渲染方程中BRDF是和材质直接绑定的。表面材质的本质是其反射光的方式。也就是说材质==BRDF。</p>
<h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>eg：</p>
<p><img src="/images/2023-09-09-09-35-12.png" alt></p>
<p>上图为漫反射材质。</p>
<p><img src="/images/2023-09-09-09-35-32.png" alt></p>
<p>如果点不发光，也不吸收光，那么能量进来多少，就会被反射多少，不会有损失的能量。</p>
<p><img src="/images/2023-09-09-09-43-49.png" alt></p>
<p>上述公式描述的是漫反射系数的定义过程，具体来说就是：</p>
<p>fr作为BRDF是常数Li也是常数，由于我们反射是对所有半球上的方向进行积分，所以积分结果就是PI。如果我们要获得遵循能量守恒，Lo==Li，所以fr=1/PI。然后我们定义一个系数反射率（albedo，可以是一个数，可以是一个rgp，也可以是光谱）。</p>
<h3 id="glossy反射"><a href="#glossy反射" class="headerlink" title="glossy反射"></a>glossy反射</h3><p>有反射，同时会往一个范围内反射。</p>
<p><img src="/images/2023-09-09-09-51-59.png" alt></p>
<h3 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h3><p>有反射有折射。</p>
<p><img src="/images/2023-09-09-09-54-46.png" alt></p>
<p>反射公式为：</p>
<p><img src="/images/2023-09-09-10-03-50.png" alt></p>
<p>该公式有两个理解方式：</p>
<ol>
<li>使用第一个图的思路来理解，作平行四边形，由此列出等式：反射光加入射光等于2 <em> cos与法线夹角 </em> 法线。由此计算出反射光。</li>
<li>第二个图的思路是使用方位角的思路来进行求解的。</li>
</ol>
<p>下图为镜面反射的BRDF效果：</p>
<p><img src="/images/2023-09-09-10-12-03.png" alt></p>
<p>在镜面反射中，折射现象的计算方式：</p>
<p><img src="/images/2023-09-09-10-15-28.png" alt></p>
<p>入射角和折射角分别与其折射率相乘，结果相等。如果有了折射率，我们就可以计算出折射角。以下有一些物体常见的折射率：</p>
<p><img src="/images/2023-09-09-10-17-13.png" alt></p>
<p>折射法则：</p>
<p><img src="/images/2023-09-09-10-20-36.png" alt></p>
<p>要使ηi&gt;ηt时才会出现折射现象。否则根号下结果小于0，不能计算。否则就会出现全反射现象。</p>
<p><strong>菲涅尔项</strong>：用于表述有多少能量被反射和折射。</p>
<p>计算方式：</p>
<p><img src="/images/2023-09-09-10-40-10.png" alt></p>
<p>计算两个极化的情况然后求平均（麻烦）</p>
<p>简化方法：</p>
<p><img src="/images/2023-09-09-10-40-56.png" alt></p>
<p>这种方法是一个拟合的方法。</p>
<h3 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h3><p>在较远的位置观察，我们可能看到的结果是一个粗糙平面，而近处看则是凹凸不，且每个微元都是镜面反射。</p>
<p>虽然每个微元的反射方向不同，但是其宏观来观察是趋近于一个方向的（表面不够粗糙的话）。如果表面过于粗糙，那么其分布范围就会变大，会形成一个类似于漫反射的效果。</p>
<p><img src="/images/2023-09-09-10-49-14.png" alt></p>
<p>具体的做法是：</p>
<p><img src="/images/2023-09-09-10-50-34.png" alt></p>
<p>其BRDF主要和三个数据相关，第一个是菲涅尔项（主要是判断反射率），第二个是几何项（主要是微表面自己表面间的遮挡关系），第三个是法线分布函数。</p>
<p>渲染案例：</p>
<p><img src="/images/2023-09-09-11-04-27.png" alt></p>
<p>该类模型常用于PBR。</p>
<p>其常常出现的问题是散射光较少，可能需要对此进行额外处理。</p>
<h3 id="各向异性的材质"><a href="#各向异性的材质" class="headerlink" title="各向异性的材质"></a>各向异性的材质</h3><p>各项同性：模型微表面不存在一定的方向性。</p>
<p>各项异性：微表面的法线分布具有一定的方向性。</p>
<p>各向异性的渲染效果：</p>
<p><img src="/images/2023-09-09-11-17-35.png" alt></p>
<p>还可以表现织物和天鹅绒这样的效果。</p>
<h3 id="BRDF的性质"><a href="#BRDF的性质" class="headerlink" title="BRDF的性质"></a>BRDF的性质</h3><p><strong>线性性质：</strong></p>
<p><img src="/images/2023-09-09-11-22-31.png" alt></p>
<p><strong>可逆性：</strong></p>
<p><img src="/images/2023-09-09-11-22-55.png" alt></p>
<p>交换入射方向和出射方向结果相同</p>
<p><strong>能量守恒：</strong></p>
<p><img src="/images/2023-09-09-11-23-40.png" alt></p>
<p>不会凭空产生能量，也不会凭空减少（吸收不是凭空减少）。</p>
<p><strong>各向同性和各向异性：</strong><br>各向同性意味着BRDF只和相对的方位角有关（可以降低一维），同时具有可逆性。</p>
<p><img src="/images/2023-09-09-11-27-21.png" alt></p>
<h3 id="真正的BRDF"><a href="#真正的BRDF" class="headerlink" title="真正的BRDF"></a>真正的BRDF</h3><p>需要实际测量：</p>
<p><img src="/images/2023-09-09-11-31-29.png" alt></p>
<p><img src="/images/2023-09-09-11-32-52.png" alt></p>
<p>在一个方向照射光，然后使用一个摄像机进行数据收集。也有一种思路是使用深度学习的方式来进行求取。介绍的库：</p>
<p><img src="/images/2023-09-09-11-37-01.png" alt></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/03/games101%E7%AC%94%E8%AE%B013-15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/03/games101%E7%AC%94%E8%AE%B013-15/" class="post-title-link" itemprop="url">games101笔记13-15</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-03 10:25:08" itemprop="dateCreated datePublished" datetime="2023-09-03T10:25:08+08:00">2023-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-05 13:26:14" itemprop="dateModified" datetime="2023-09-05T13:26:14+08:00">2023-09-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十三课"><a href="#第十三课" class="headerlink" title="第十三课"></a>第十三课</h1><h2 id="Whitted-Style光线追踪"><a href="#Whitted-Style光线追踪" class="headerlink" title="Whitted-Style光线追踪"></a>Whitted-Style光线追踪</h2><p>光线追踪与光栅化是两种不同的着色方式。</p>
<p>光栅化最大的问题是不能很好的去表示全局效果，不能很好的展现软阴影、光泽反射、间接光照等。</p>
<p>光线追踪相对于光栅化更加的准确，但是其工作开销更大，目前较多的应用在影视中，但是由于gpu性能的提升最近越来越多的游戏也开始支持光追了。</p>
<p>在光追中，我们分析光线发现其有以下性质（视觉上，抛开物理不谈）：</p>
<ol>
<li>光是直线</li>
<li>光不会交叉</li>
<li>光线从光源发出，在场景中反复反射，最后到达观察者眼中。（光的可逆性，也就是说我们可以顺着我们看到的光线，可以找到光源）</li>
</ol>
<p>光追中的追踪是从我们的观察点出发，经过反射，找到光源。</p>
<p><strong>光线投射</strong>：从视觉点发射一个射线到一个像素上，找到该像素对应的空间中的点，计算该点是否被光线照射到，有了观察向量、光线向量以及法向量，就可以通过光照模型来进行着色了。</p>
<p><img src="/images/2023-09-03-10-55-12.png" alt></p>
<p><strong>Whitted-Style</strong>工作效果：</p>
<p><img src="/images/2023-09-03-10-54-54.png" alt></p>
<p>其工作方式为：和光线投射相似，当从视点发射一个射线后，我们计算其接触点的反射向量和折射向量，并计算反射折射向量的对应反射和折射。然后我们会计算这些向量接触物体的点判断光线是否可以照亮，然后通过获得的向量信息进行着色。（折射反射的光线一般会有衰减，否则会过度曝光）</p>
<p><img src="/images/2023-09-03-11-03-52.png" alt></p>
<p>光追中的技术问题：</p>
<ol>
<li>计算射线到物体上的交点。射线的定义：使用两个量来定义，起点o和方向d。</li>
</ol>
<p><img src="/images/2023-09-03-11-08-21.png" alt><br>和球做交点：</p>
<p><img src="/images/2023-09-03-11-13-30.png" alt><br>上述计算公式只有t为未知量，我们可以直接解方程获得t的取值。</p>
<p>根据上述内容推断，我们对于各种物体的求解方法如下：</p>
<p><img src="/images/2023-09-03-11-20-12.png" alt></p>
<p>只需要解出t即可获得结果。</p>
<ol>
<li><p>不规则网格的交点求取：按照求交的方法对所有面片进行计算开销过大。先说明求交点的方法：<br>光线和三角形求交可以先转化为光线和平面求交，再求点是否在三角形内。</p>
<p>平面的定义方法：一个方向（法线）和一个点。法线可以确定面的朝向，点确定面的位置。</p>
<p><img src="/images/2023-09-03-11-27-29.png" alt></p>
<p>计算光线和平面的交点，可以先判断一个点是否在平面内：<br><img src="/images/2023-09-03-11-32-30.png" alt></p>
<p>也就是平面上的点和定义平面的点连成的向量与n垂直就说嘛其在平面内。更具上述式子，我们可以设计对应的计算公式（关于t的方程）：<br><img src="/images/2023-09-03-11-33-52.png" alt></p>
<p>带入后有：(o + td - p’)点乘 N = 0</p>
<p>由此式子解出t的值（t大于等于0）</p>
<p>求出交点后，我们判断该点是否在三角形内即可（边向量和点叉乘判断结果符号是否相同）</p>
<p>整个流程较长，是否有较简单的算法呢？</p>
<p><img src="/images/2023-09-03-11-38-34.png" alt></p>
<p>用三角形的重心点来和射线交点进行判断，使用线代的计算方法来进行计算的简化。只需1-b1-b2、b1、b2大于0即说明点在三角形内。</p>
<p>但是就算使用了计算加速，我们还是需要对所有的三角型进行计算，开销还是非常大。以下述场景为例：<br><img src="/images/2023-09-03-11-46-24.png" alt><br>该场景共有1000多万个三角面片，使用上述思路渲染开销极大。我们要寻找一种方法来进行加速。为了加速我们可以提出一个概念：<br><strong>包围盒</strong></p>
<p>包围盒的概念：如果我们有一个复杂的物体，我们可以使用一个简单的几何体将其包围，这个包围的简单几何体就是包围盒。</p>
<p>如果我们的光线连包围盒都无法接触，那么我们就不对该包围盒中的面片进行计算。</p>
<p><strong>AABB</strong>包围盒：长方体，且平每个面行于xyz轴（世界坐标系）。</p>
<p>如何判定射线和包围盒相交呢？<br>判断射线和包围盒和三个轴的平行边是否有交点：<br><img src="/images/2023-09-03-11-59-34.png" alt><br>上图拓宽到三维空间，我们就会获得三组tmin、tmax,我们找到最大的tmin，找到最小tmax，就可以知道光线何时进入盒子何时离开盒子。如果我们的进入时间小于离开时间，则说明有交点，否则无交点。如果离开时间小于0，说明无交点；如果离开时间大于等于0，进入时间小于0，则说明光源在物体内，一定有交点。</p>
<p>总结aabb和光线有交点的条件是：进入时间&lt;离开时间&amp;&amp;离开时间&gt;=0</p>
</li>
</ol>
<h1 id="第十四课"><a href="#第十四课" class="headerlink" title="第十四课"></a>第十四课</h1><h2 id="aabb如何提速光追"><a href="#aabb如何提速光追" class="headerlink" title="aabb如何提速光追"></a>aabb如何提速光追</h2><p>包围盒中的进行预处理，将包围盒进行空间划分，将有物体的格子做额外记录：<br>   <img src="/images/2023-09-03-16-11-53.png" alt></p>
<p>   经过预处理，我们判断光线是否经过盒子中包含物体的空间块，如果通过就开始计算是否和物体有交点。</p>
<p>   判定光线通过的空间块的方法有：bresenham算法的思想（直线绘制算法），把分割空间类似为一个光栅化的格子，然后用直线绘制方法来进行判定（但是不用，只是一个思路）。在实际的运用中，空间分割的空间块的数量一般是要取一个平衡值的（太多了运算开销大，少了不能准确找到物体）。</p>
<p>   缺点：如果有物体分布不够多，会占用大量的时间，优化效果不好。</p>
<h2 id="空间划分"><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h2><p><img src="/images/2023-09-03-16-33-28.png" alt></p>
<h3 id="Oct-tree"><a href="#Oct-tree" class="headerlink" title="Oct-tree"></a>Oct-tree</h3><p>八叉树，将空间分为4块，将每个子节点再分为四块（在三维空间为8块）。在物体较多的格子继续划分，没有物体的格子不再划分。这也可以防止平均划分出现的缺点。</p>
<h3 id="KD-tree"><a href="#KD-tree" class="headerlink" title="KD-tree"></a>KD-tree</h3><p>和八叉树几乎完全相同，每次分割的时候二分，获得结果类似于二叉树，且不是固定的二分，而是动态的二分。例如上图中每次划分都不是水平划分的。在三维中，我们就每次分别按照x-&gt;y-&gt;z这样的过程来进行二分。</p>
<h3 id="BSP-tree"><a href="#BSP-tree" class="headerlink" title="BSP-tree"></a>BSP-tree</h3><p>每一次选一个方向，对空间进行二分（不是很平竖直的分割）。但是问题是在高维时计算会很复杂，例如三维就不是一个线了，而是一个旋转的平面。</p>
<h2 id="KD-tree-1"><a href="#KD-tree-1" class="headerlink" title="KD-tree"></a>KD-tree</h2><p><img src="/images/2023-09-03-16-43-19.png" alt></p>
<p>上图蓝色部分也要同b一样操作，这里省去了。KD-tree的目的是尽量将物体存储在二叉树的叶子节点中。</p>
<p>射线在KD-tree中遍历的过程是从根节点开始判断是否经过该节点，通过则继续进入之后节点的判定，直到我们遇到了叶子节点，如果和叶子节点有交点则与该节点中的所有三角形做交点的判定。该过程可以有效的剪枝，从而达到加速的效果（这是一种较为简单的方法）。</p>
<p>缺点：一个物体可能存在多个节点中，kd-tree很难建立（要考虑三角形和格子的求交）</p>
<h2 id="BVH"><a href="#BVH" class="headerlink" title="BVH"></a>BVH</h2><p>原理：</p>
<ol>
<li>首先将场景做一个包围盒。</li>
<li>将物体分为两个部分，将两部分分别求包围盒。</li>
<li>继续划分。</li>
<li>叶子节点中物体数量达到需求即可结束。<br><img src="/images/2023-09-03-17-03-53.png" alt></li>
</ol>
<p>优点：一个物体只在一个叶子节点中，同时不用判定三角形和边界的问题。</p>
<p>存在的小问题：对空间的划分没有严格的划分开，会出现相交的情况。</p>
<p>分割思路：每次选择最长的轴进行分割。分割的物体选择一般是通过快速选择算法来选出中位数，具体思路是将物体对应轴的值存入（无序）然后通过快速排序的思想来找到第n/2个数，然后以此物体进行划分。</p>
<p>经过上述的分割，我们就获得了一个BVH的树，中间节点只存包围盒，叶子节点存物体。</p>
<p>具体的求交方法：</p>
<p><img src="/images/2023-09-03-17-26-09.png" alt></p>
<p>（同KD-tree，递归求交，直到叶子节点）</p>
<p><strong>至此，光追的加速部分结束。</strong></p>
<h2 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h2><p>是高级的光追（区别于Whitted-Style）。</p>
<p>其工作是描述光线，且还是基于几何度量学来做的。</p>
<p>该部分的学习目的：搞清楚<strong>Radiant flux,intensity,irradiance,radiance</strong>是什么。</p>
<p>题外话：学习一个东西的顺序是为什么学，学什么，学的东西具体是怎么做的。</p>
<h3 id="Radiant-flux"><a href="#Radiant-flux" class="headerlink" title="Radiant flux"></a>Radiant flux</h3><p>radiant energy：是一种能量，单位焦耳。<br>Radiant flux：单位时间的能量，也就是功率，单位瓦特。</p>
<h3 id="Radiant-intensity"><a href="#Radiant-intensity" class="headerlink" title="Radiant intensity"></a>Radiant intensity</h3><p>定义：能量除以立体角。也就是功率除以立体角。单位是cd（candela坎德拉）。</p>
<p>什么是立体角：一般定义角使用弧度来定义</p>
<p><img src="/images/2023-09-03-17-51-16.png" alt></p>
<p>角度等于弧长/半径。整个圆的角度为2pi。立体角则是在三维空间中的延伸：</p>
<p><img src="/images/2023-09-03-17-52-24.png" alt></p>
<p>立体角等于球体部分面积/半径的平方，球体的立体角就是4pi。</p>
<p>单位立体角：使用一个较小的面积来定义：</p>
<p><img src="/images/2023-09-03-17-53-39.png" alt></p>
<p>对于整个球来说：</p>
<p><img src="/images/2023-09-03-17-55-18.png" alt></p>
<p>总结一下立体角：<br>我们给出任意一个面片，面片面积为dS，法线方向为n，对某一点o所张开的立体角的求取方式：首先知道球体半径为r，r方向与法线放线的夹角就是面片与o点以r为半径切出的球面的的夹角，于是椎体的球面部分的面积就是dS * cosθ（θ为面之间的夹角）。当然如果面片直接存在于球体上，我们的计算方式可以变为通过其中心到o点对于坐标轴中变化的角度来求取，如上图中的θ以及Φ分别为关于z轴的夹角以及关于z轴旋转的角度。我们将面片近似为方片，获得其面积公式：</p>
<p><img src="/images/2023-09-03-17-54-23.png" alt></p>
<p>再除以r²：</p>
<p><img src="/images/2023-09-03-17-54-57.png" alt></p>
<p>这样就获得了Radiant intensity。</p>
<h1 id="第十五课"><a href="#第十五课" class="headerlink" title="第十五课"></a>第十五课</h1><p>光线传播和全局光照：</p>
<h2 id="辐射度量学（接上节）"><a href="#辐射度量学（接上节）" class="headerlink" title="辐射度量学（接上节）"></a>辐射度量学（接上节）</h2><p>回顾：<br>Radiant flux（power）：单位时间内的能量。本课程中使用的能量考虑的都是单位时间能量。</p>
<p>Radiant intensity：一个立体角上的能量。</p>
<p>立体角：正对球心的面积（将物体投影到球上的面积）除以半径的平方。描述了一个空间中锥张开的大小。 微分立体角的求取方式就是上节课结尾使用的求取方式。</p>
<p>新概念：</p>
<p>irradiance：能量除以面积，和Radiant intensity的区别是计算的为面积上的大小。能量的方向需要与照射面垂直，不垂直计算其投影再计算。</p>
<p>先回顾一下着色部分的内容：兰伯特余弦定律</p>
<p><img src="/images/2023-09-05-09-44-41.png" alt></p>
<p>我们定义的是必须垂直于面，例如上图第二种情况，我们发现其只接收了一般一半，所以我们直接将整个光线倾斜的角度进行投影计算。</p>
<p><img src="/images/2023-09-05-09-50-27.png" alt></p>
<p>我们可以使用irradiance来分析上图：</p>
<p><img src="/images/2023-09-05-09-51-13.png" alt></p>
<p><img src="/images/2023-09-05-09-51-33.png" alt></p>
<p>我们会发现他一直在衰减，而Radiant intensity没有衰减（立体角没有改变）。</p>
<p>Radiance（重要）:</p>
<p>定义：单位立体角和单位面积上有多少能量。（两次微分，单位立体角和单位面积） </p>
<p><img src="/images/2023-09-05-10-11-20.png" alt></p>
<p><strong>irradiance和Radiance的区别：</strong> Radiance就是在irradiance的基础上增加了一个方向性。</p>
<p><img src="/images/2023-09-05-10-20-01.png" alt></p>
<p>由于L是能量除以面积和立体角，所以E可以是L <em> cosθ </em> ω（ω为某一个方向射来的光线）。从几何上来说，就意味着，某一个立体角方向射到区域A上的能量是多少。但是由于光是从四面八方射来的，我们可以进行一个积分计算，获得所有能量：</p>
<p><img src="/images/2023-09-05-10-27-40.png" alt></p>
<p>其中H²为单位半球。</p>
<h2 id="BRDF-双向反射分布函数-反射方程"><a href="#BRDF-双向反射分布函数-反射方程" class="headerlink" title="BRDF(双向反射分布函数)反射方程"></a>BRDF(双向反射分布函数)反射方程</h2><p>光线射入物体表面被吸收，物体表面再发射光线出去。例如从某个立体角方向的光线射入到某个点(单位面积)，该点吸收了能量，然后该点会向另一个方向辐射出光线的能量。</p>
<p>而BRDF则是将这个过程进行一个描述，即某一点从某个立体角方向获得的能量会如何分配到反射到其他的立体角上。</p>
<p><img src="/images/2023-09-05-10-41-57.png" alt></p>
<p>上图就是该公式的原理即：初射方向上射入某一个位置的radiance会在受照射点上留下irrandiance，用radiance除以irrandiance就可以获得反射出的能量的比例。<br>也就是下述公式：</p>
<p><img src="/images/2023-09-05-12-08-50.png" alt></p>
<p>至于如何反射，我们需要考虑反射的类型：<br>镜面反射的话会直接不向其他位置反射，漫反射则会均等的反射到各个方向等。</p>
<p>其概念就是描述了光线和物体的作用方式。这个可以决定物体不同材质的具体反射性质。</p>
<p>工作流程：<br><img src="/images/2023-09-05-12-17-45.png" alt></p>
<ol>
<li>计算每一个入射光线到照射点的radiance。</li>
<li>乘上cosθ（兰伯特余弦定律）</li>
<li>乘上BRDF。(这一步是用来判断radiance的反射比例是多少)</li>
<li>结果就是观察点能够观察到的颜色。</li>
</ol>
<h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><p>如果我们只考虑光线弹射一次，我们的只有光源的radiance。但是一般物体都会反射，所以其光源肯定不为一个。</p>
<p>渲染方程：</p>
<p><img src="/images/2023-09-05-12-26-18.png" alt></p>
<p>Le是物体自发光发出的randiance（不发光则没有），第二部分为射入的物体并反射到Lo的光线。所有的光线传播则可以用上述公式来表示，这就是渲染方程。物体表面的光线传播都是满足这个渲染方程的（重点在BRDF）。</p>
<p>如果我使用一个面光源来照射一个点，则我们可以将面光源分成点光源，作为点光源的集合，我们就将之积分求出面光源射入的radiance。</p>
<p>同时我们射入的光还有可能是其他物体的反射光，但是具体的反射光大小我们是不知道的，但是我们可以通过递归的方式来进行具体的计算，因为在这个过程中，我们以知入射角、材质（BRDF）、光源、自发光。唯一未知的就是其他物体的反射光，同时反射光是由场景光源发射的光获取的，所以我们通过递归，递归的最后结果就是找到只有光源的状况，然后逐步计算反射光，最后获得我们的结果。</p>
<p><img src="/images/2023-09-05-12-45-07.png" alt></p>
<p>我们还可以继续简写：</p>
<p><img src="/images/2023-09-05-12-46-32.png" alt></p>
<p>L左是物体辐射出的能量、E是自己发出的能量、K是反射操作符、L右是其他物体发出的能量。这样写的目的是为了解方程，由于L是递归定义的，所以经过数学的变换可以获得如下结果：</p>
<p><img src="/images/2023-09-05-12-48-33.png" alt></p>
<p>下述结果为1-K的逆的展开（类似泰勒公式）。其结果我们可以理解为我们看到的最后一个图片的L是由我们光源经过多次反射的和得到的结果（妙啊）。这就是全局光照的原理。</p>
<p>一些渲染效果：<br><img src="/images/2023-09-05-12-55-58.png" alt></p>
<p>上述为直接光照效果</p>
<p><img src="/images/2023-09-05-12-56-44.png" alt></p>
<p>上述为一次间接光照的效果</p>
<p><img src="/images/2023-09-05-12-57-07.png" alt></p>
<p>上述为三次间接光照效果</p>
<p><img src="/images/2023-09-05-12-57-43.png" alt></p>
<p>上述为四次的效果。</p>
<p>上面三次和四次有个灯的有区别，三次反射次数不能将灯中的光射出，所以较暗，但是四次正好灯中的光射出了，所以可以看清灯。</p>
<p>如果做无限次反射，那么就会收敛到一个亮度。</p>
<h2 id="简单的概率论回顾"><a href="#简单的概率论回顾" class="headerlink" title="简单的概率论回顾"></a>简单的概率论回顾</h2><p>随机变量和概率的回顾（学过不赘述了）。</p>
<p>概率：非负、和为1.<br>期望：对应随机变量*概率然后加上所有项。（例如骰子的期望是3.5）。</p>
<p>PDF（连续情况下如何描述变量以及分布）：概率密度函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/09/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A002/" class="post-title-link" itemprop="url">算法学习02</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-02 15:50:17" itemprop="dateCreated datePublished" datetime="2023-09-02T15:50:17+08:00">2023-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 10:14:43" itemprop="dateModified" datetime="2023-11-16T10:14:43+08:00">2023-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="旧题复习"><a href="#旧题复习" class="headerlink" title="旧题复习"></a>旧题复习</h1><h2 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h2><p>leetcode链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/</a><br>这个题目的解法有很多，解法有两种，一种是全平方后进行排序，第二种是使用更多的空间将每一个数字平方后的结果使用双指针进行遍历并插入，然后返回新数组。可以使用双指针的原理是因为原本就是有序排列的，头部的数据的平方可能会大于尾部数据的平方（因为可能为负数）。<br>这里给出第二种解法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(min&lt;=max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[min])&lt;<span class="built_in">abs</span>(nums[max]))</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),nums[max]*nums[max]);</span><br><span class="line">            max--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),nums[min]*nums[min]);</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="leetcode每日一题"><a href="#leetcode每日一题" class="headerlink" title="leetcode每日一题"></a>leetcode每日一题</h1><h2 id="最多可以摧毁的敌人城堡数目"><a href="#最多可以摧毁的敌人城堡数目" class="headerlink" title="最多可以摧毁的敌人城堡数目"></a>最多可以摧毁的敌人城堡数目</h2><p>原题链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/?envType=daily-question&amp;envId=2023-09-02">https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured/?envType=daily-question&amp;envId=2023-09-02</a></p>
<p>题目要求为求取最多能够摧毁的城堡数量。这里我的思路是使用快慢双指针的方法该，使用快慢指针来遍历数组，如果遇到可以出发的地方（无论是空地还是自己的城堡，因为方向是无所谓的），就开始移动快指针，如果快指针遇到敌人城堡则增加计数器，否则判断是否和出发点的类型相同，如果不同的话，则表示这个流程是合理的，我们判断计数器是否为最大值，否则该流程作废。完成之后将慢指针跳跃到快指针位置，继续遍历。</p>
<p>解题代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(fast&lt;forts.<span class="built_in">size</span>())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>((forts[slow]==<span class="number">1</span>||forts[slow]==<span class="number">-1</span>)&amp;&amp;fast==slow)<span class="comment">//找到入口的情况</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">               <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//快指针的遍历</span></span><br><span class="line">               &#123;</span><br><span class="line">                   fast++;</span><br><span class="line">                   <span class="keyword">if</span>(fast&gt;=forts.<span class="built_in">size</span>())<span class="comment">//快指针超出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span>(forts[fast]!=<span class="number">0</span>)<span class="comment">//找到非敌人堡垒</span></span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">if</span>(forts[fast]==forts[slow])<span class="comment">//判断流程是否可用</span></span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="keyword">if</span>(sum&gt;=res)<span class="comment">//可用时更新最大摧毁数</span></span><br><span class="line">                               res = sum;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   sum++;<span class="comment">//摧毁敌人城堡计数器</span></span><br><span class="line">               &#125;</span><br><span class="line">               slow = fast;<span class="comment">//慢指针跳转</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span><span class="comment">//初始为0的情况</span></span><br><span class="line">           &#123;</span><br><span class="line">               slow++;</span><br><span class="line">               fast++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="消灭怪物的最大数量"><a href="#消灭怪物的最大数量" class="headerlink" title="消灭怪物的最大数量"></a>消灭怪物的最大数量</h2><p>leetcode原题链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/">https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/</a></p>
<p>解题思路：该题可以使用贪心的思路来解决。首先分析题目：所有怪物是会移动的，其次我们每一分钟才能发射一次。出现不能防守的情况就是怪物到达，我们却无法射击，所以我们需要注意的核心数据是时间。我们可以使用一个数组来计算每一个怪物到达城市所需要花费的时间。我们只需要抓紧时间击杀掉时间最短的怪物即可，获取了怪物到达时间之后，我们进行一下排序，然后遍历该数组即可（遍历的过程就代表了每分钟攻击一次，将最前方的怪物击杀）。如果出现了索引值大于当前时间的情况，说明我们没有时间开枪将怪物击败，怪物已经到达了城市，这是返回我们花费的时间即可。</p>
<p>以下为解题代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">eliminateMaximum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">float</span>&gt; times;<span class="comment">//使用float类型来进行时间存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;dist.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            times.<span class="built_in">push_back</span>((<span class="type">float</span>)dist[i]/speed[i]);<span class="comment">//存入时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(times.<span class="built_in">begin</span>(),times.<span class="built_in">end</span>());<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;times.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果出现了怪物的到达时间快于我们攻击的cd时间（等于的情况是怪物正好到达，但是我们cd也刚好，这样也判为输）</span></span><br><span class="line">            <span class="keyword">if</span>(times[i]&lt;=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="comment">//这里判断是+1是因为第一只怪物如果移动速度很快，我们也可以很快的将其消灭（开始时无cd）</span></span><br><span class="line">                    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist.<span class="built_in">size</span>();<span class="comment">//全部消灭</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a>最后一块石头的重量 II</h2><p>leetcode链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p>
<p>解决思路：<br>根据题目要求，我们需要每一次选出两块石头，然后进行粉碎，如果石头重量相同，两块石头消失，否则生成一块重的石头减去轻的石头的重量的石头。题目中所做的工作我们放在整体上去看，实际上就是将石头分为两个部分，两个部分的重量要尽可能的相同，求两部分石头相减后的最小值。</p>
<p>要获得这个最小值就要使得两部分石头的重量尽可能的大。这样想，这个题目其实和分割等和子集的思路是较为接近的。我们可以求出总重量，然后使用01背包的思想来记录重量。最优解其实就是总重量的一半处。</p>
<p>根据上述分析，我们可以来进行dp数组的设计，这里采用滚动数组，dp数组的下标代表了石头的总重量，计算总重量后再开辟数组空间，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += stones[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n = sum;</span><br><span class="line">sum/=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>由此我们获得了dp数组。之后我们通过递推公式将石头放入递推数组中。其意义为在这个载重下，能放入的最大石头重量。具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = n;j&gt;=stones[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体递推过程可以参考算法学习01（如果你想不起来了记得去看）。</p>
<p>由此，我们所期望的最优值是dp数组为中值时能放入的最大重量的石头，我们只需要返回两部分的差值即可。一部分为n-dp[sum],这是没有放入背包的石头重量，另一部分为dp[sum]，这是最优条件下能够放入背包的重量。两者相减获得我们的结果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/08/31/games101%E7%AC%94%E8%AE%B010-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/31/games101%E7%AC%94%E8%AE%B010-12/" class="post-title-link" itemprop="url">games101笔记10-12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-31 14:45:37" itemprop="dateCreated datePublished" datetime="2023-08-31T14:45:37+08:00">2023-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-02 14:52:16" itemprop="dateModified" datetime="2023-09-02T14:52:16+08:00">2023-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第十课"><a href="#第十课" class="headerlink" title="第十课"></a>第十课</h1><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><h3 id="环境纹理"><a href="#环境纹理" class="headerlink" title="环境纹理"></a>环境纹理</h3><p>纹理就是一张图，更是一组数据。我们可以对纹理做各种操作例如mipmap，各向异性等。我们甚至可以将纹理作为一个环境光让物体上能映射出环境：<br><img src="/images/2023-08-31-14-58-21.png" alt><br><img src="/images/2023-08-31-15-02-54.png" alt><br>将不同的环境光记录在球面上，然后将其展开，我们会发现长方形展开时，上下边会有一定的扭曲。<br><img src="/images/2023-08-31-15-06-07.png" alt><br>解决方法是使用一个球体的包围盒来存储纹理图片，这样获得的结果展开后就会获得6张图片，这样操作就不会产生扭曲问题了。</p>
<h3 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h3><p>纹理不仅仅可以用来描述颜色，还可以用来定义任何不同位置的不同属性，例如定义一个位置的点的高度（相对于网格的基础高度）。如下图：<br><img src="/images/2023-08-31-15-11-30.png" alt><br>通过凹凸贴图将球体凹凸不平的效果表现了出来。<br>因为贴图提供了新的高度，所以法线发生了变化，由此会使得着色过程渲染出的光效产生变化，从而产生凹凸不平的感觉。实际上上图球体的面片数量和顶点数并没有改变。</p>
<p>获取法线的计算过程如下：<br><img src="/images/2023-08-31-15-33-29.png" alt><br>计算任何一个点的梯度就是求出了对应点的切线，我们用相邻两个点的高度差除以单位间隔（图中取1），获得了切线后，直接进行切线旋转，旋转90度即可（使用旋转矩阵），然后归一化。三维场景中求取法线的方式也是相同的（求两个偏导）。<br><img src="/images/2023-08-31-15-44-33.png" alt></p>
<h3 id="位移贴图"><a href="#位移贴图" class="headerlink" title="位移贴图"></a>位移贴图</h3><p>同凹凸贴图，也是输入一个纹理，但是位移贴图的作用是将网格的顶点进行移动。</p>
<p><img src="/images/2023-08-31-15-45-50.png" alt></p>
<p>可以看到效果相较于凹凸贴图效果更好一些。从阴影可以看出位移贴图是真的改变了网格模型的顶点。但是其也有一定的限制，要求网格模型的三角面片较细。这样会对性能要求较高。</p>
<h3 id="三维纹理"><a href="#三维纹理" class="headerlink" title="三维纹理"></a>三维纹理</h3><p><img src="/images/2023-08-31-15-49-29.png" alt><br>例如上图的球，我们将球体切开，可以看到内部的样式。也就说我们定义了一个三维的图片数据。并且我们可以通过一些空间数据来进行程序化的纹理生成。</p>
<p>三维纹理的应用一般在体积展示、医学等方面应用较多。</p>
<h2 id="几何部分"><a href="#几何部分" class="headerlink" title="几何部分"></a>几何部分</h2><p>在场景中，我们可能会需要很多的曲面，在CG中，我们如何去描述和实现曲面呢？细致部件如何组合？衣物布料等如何体现？大量渲染物体如何保证性能？这些都是几何部分需要解决的问题。</p>
<p>几何分为两类，一类是隐式几何，另一类是显式几何。</p>
<h3 id="隐式方法"><a href="#隐式方法" class="headerlink" title="隐式方法"></a>隐式方法</h3><p>不会明确表述顶点的位置，而是通过一些方法告诉你哪些点在几何内。这就是隐式表示的方法。例如一个球，满足x²+y²+z²=1的点，都在球体的表面上。所以我们可以使用一个式子来表示隐式几何：f(x,y,z)=0。</p>
<p>但是隐式方法也有一些不足，就是通过公式无法明确具体形状。但是作为是否在面上的判断方法，是非常容易的。如果带入点后结果小于0，或者大于0或者等于0，可以得知该点是在物体内还是物体外还是物体上。</p>
<p>同时还有一些其他的方法：</p>
<p>CSG：通过一系列基本几何的运算来表示几何（布尔运算）。</p>
<p>距离函数表示：使用一个函数来表示物体，函数的自变量为空间中的任意一点，因变量为该点到物体表面的距离。在物体外为正，在物体内为负。这种表示方式可以用来做很多东西，例如液体水滴相互接近时发生的融合的变化等。这个过程其实就是两个用距离函数来表示的几何相互接近并在一定的范围内求平均的过程。</p>
<p>水平集表示：如果距离函数不好表示，可以采用水平集的方式，水平集类似于等高线，等高线处为0，在光栅化的网格中可以通过双线性插值的方法来获得这个歌等高线。</p>
<p>分型表示。（可参考L系统）</p>
<h3 id="显式方法"><a href="#显式方法" class="headerlink" title="显式方法"></a>显式方法</h3><p>我们记录一系列顶点的位置，或者是使用uv来映射空间中的顶点。这就是显式的表示方法。例如：<br><img src="/images/2023-08-31-16-19-08.png" alt><br>就是将二维的uv映射出xyz，结果如下：<br><img src="/images/2023-08-31-16-19-32.png" alt></p>
<p>显式难以求点和物体间的关系。</p>
<p>两种方法的选择要看情况来定。</p>
<h1 id="第十一课"><a href="#第十一课" class="headerlink" title="第十一课"></a>第十一课</h1><h2 id="显式表示（接上节）"><a href="#显式表示（接上节）" class="headerlink" title="显式表示（接上节）"></a>显式表示（接上节）</h2><p>点云表示：用极多的点来表示一个物体，只要点够多，就可以让人看不出物体是由点来表示的，使用此方法如果数量过少可能难以看出是一个面。<br><img src="/images/2023-09-01-16-30-21.png" alt></p>
<p>多边形网格表示：使用较多是多边形和三角形（三角形最多）。<br><img src="/images/2023-09-01-16-34-38.png" alt></p>
<p>如果使用面片来表示物体，面片间的连接就会需要大量的信息来存储。<br><img src="/images/2023-09-02-10-03-20.png" alt></p>
<p>图片中为.obj的文本文件，用于存储物体信息。上图中v代表的是顶点，顶点有八个。vn为法线，上图表示的为一个立方体，每个面一个法线所以有六个。其中有两个因为精度问题是可以省略的。vt是纹理坐标，由于立方体是采取四个顶点一个面的，所以每个面需要定义四个顶点的纹理信息，故有最多会有24个纹理坐标，不过里面有公用的情况，所以一般是小于最大值的。上图中有14个，其中也有冗余。f表示连接关系，一行代表了：<strong>顶点v/纹理坐标vt/法线vn</strong>。通过这种形式，我们就可以定义出一个网格模型了。</p>
<h3 id="曲线曲面"><a href="#曲线曲面" class="headerlink" title="曲线曲面"></a>曲线曲面</h3><h4 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h4><p>贝塞尔曲线：一种显式的表示方法。</p>
<p>原理：使用一系列的控制点来表示一个曲线。<br><img src="/images/2023-09-02-10-17-36.png" alt><br>用四个点来确定曲线（必须经过起始点）。</p>
<p>如何绘制贝塞尔曲线？</p>
<p>以三个点为例：首先定义b0到b1的一个点，该点从0开始到1，由时间t来决定位置，同样我们再设置一个点在b1到b2之间，获取方式同上一步。之后连接刚刚取的两个点。连线上再获取一个点，该点位置也是由t来获取。</p>
<p><img src="/images/2023-09-02-10-23-32.png" alt></p>
<p>最后我们遍历所有的t（t虽然是连续量，但是我们将其离散表示），就可以获得曲线了。同理我们可以获得四个点的表示方法：</p>
<p><img src="/images/2023-09-02-10-26-12.png" alt></p>
<p>可以看出这是一个递归的过程。<br>整个算法的输入为点的位置信息，以及时间t。没两个点我们找到一个新的点，再从新的点中找到两个点求出更多的点，直到只有一个点时，记录该点的位置作为输出。</p>
<p><img src="/images/2023-09-02-10-33-08.png" alt></p>
<p>每一次递归中我们做的是线性插值（核心思想）。<br><img src="/images/2023-09-02-10-35-59.png" alt><br>任意阶的贝塞尔曲线，就是由伯恩斯坦多项式作为系数的加权。通过上述特点，我们发现贝塞尔曲线不需要将所有点都安排到一个平面内，三维环境下只要有对应的点，我们就可以求出对应的曲线。eg：<br><img src="/images/2023-09-02-10-38-25.png" alt></p>
<p>贝塞尔曲线具有的优秀性质：起始点在输入顶点的起点和终点上，同时起始方向和终止方向对应顶点位置上线段为其切线。同时对不同顶点做仿射变换（前面课程中所说的线性拉伸）后，重新绘制的贝塞尔曲线是不变的。对于其他变换可能就不是原来的曲线了（因为可能不是线性变换）。凸包性质：曲线一定在几个控制点形成的凸包（convex hull，可以用来包围住一些指定物的最小多边形）内。</p>
<p>当控制点多后不好操作，想要一些复杂的曲线效果可以使用多个控制点来作多条连续的贝塞尔曲线，一般以四个为一组来表示贝塞尔曲线。<br><img src="/images/2023-09-02-10-50-09.png" alt><br>上图就是每四个点来确定的贝塞尔曲线。ps中的钢笔工具就是贝塞尔曲线实现的（每四个一组的形式）<br><img src="/images/2023-09-02-10-52-24.png" alt></p>
<p>其他的曲线：<br>样条线：b样条线，较为复杂。</p>
<h4 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h4><p><img src="/images/2023-09-02-11-04-37.png" alt><br>贝塞尔曲面，其原理是类似于贝塞尔曲线。我们以一个4*4控制点的曲面为例：<br>我们在两个方向上做贝塞尔曲线。<br><img src="/images/2023-09-02-11-06-38.png" alt><br>例如上图，我们将一个方向的四条线做贝塞尔曲线，再通过四条曲线上的点作为控制点做贝塞尔曲线，并更改t记录这些离散的点，就成为了贝塞尔曲面。使用贝塞尔曲面可能需要二维的变量来控制，我们称两个变量为uv。所以我们是直接使用uv来映射物体，故是显式表示的。</p>
<h1 id="第十二课"><a href="#第十二课" class="headerlink" title="第十二课"></a>第十二课</h1><p>对于三角形面片，我们有很多的操作：细分、较少、正则化等。</p>
<h3 id="细分操作"><a href="#细分操作" class="headerlink" title="细分操作"></a>细分操作</h3><p>最早在位移贴图时说过细分问题，使用位移贴图的需要较为细致的三角形划分，所以需要细分操作。引入更多的三角形有很多的算法。</p>
<p>细分两个目的：1.增加三角形数量。2.使得物体变得光滑。</p>
<h4 id="loop细分"><a href="#loop细分" class="headerlink" title="loop细分"></a>loop细分</h4><p>算法原理：对两种不同顶点来分别改变它们的位置（新创建的顶点和原有的顶点）。</p>
<ol>
<li>创建新的顶点：每个边上都有新的顶点。</li>
<li>如果点在两个三角形接触的边上，那么该点就会通过两个三角形的顶点（共四个点）来加权平均，最后获得其位置：<br><img src="/images/2023-09-02-12-59-38.png" alt><br>上图白点的位置计算方式如公式所展示。</li>
<li>对于旧的顶点，我们可以通过与其相关的三角形的顶点以及自身原本的位置来作为参考进行改变：<br><img src="/images/2023-09-02-13-02-52.png" alt><br>计算方法为我们定义一个度（点连接的数量对应上图中的n），然后对自身位置进行权值计算，再加上邻居位置的权值计算（权值与n有关可参考u的获取方法）。如果说，一个顶点连接了很多个三角形，那么该顶点受到其他点的影响就较大，如果比较小就受到的影响较小。</li>
</ol>
<p>loop算法工作效果：<br><img src="/images/2023-09-02-13-19-46.png" alt></p>
<h4 id="catmull-clark细分"><a href="#catmull-clark细分" class="headerlink" title="catmull-clark细分"></a>catmull-clark细分</h4><p>两个概念：非四边形面（不是四边形的面）和奇异点（度不为4的点）。<br><img src="/images/2023-09-02-13-27-17.png" alt><br>具体工作过程：<br>在所有面中定义一个点，然后取其边的中点，并连接。在这个过程之后原本的奇异点不变，新增的点也是奇异点（在几边形内创建的点就是多少度，因为要和每一个边相连）。</p>
<p><img src="/images/2023-09-02-13-30-53.png" alt></p>
<p>由此我们获得一个性质：一个网格细分后，原本有多少非四边形面，就会增加多少奇异点。之后再做多少次都不会再增加奇异点数量了。<br>如下图：<br><img src="/images/2023-09-02-13-33-44.png" alt><br>下图表示各种点如何更新：（面中间增加的点，边上增加的点，旧的点）<br><img src="/images/2023-09-02-13-37-33.png" alt></p>
<p>面中的点为平均值，线上的点为面中点和连接点的平均值，旧的点为周围所有新点的平均值（自己的位置也站一定的比重）。</p>
<p>Catmull-clark工作效果对比：<br><img src="/images/2023-09-02-13-40-27.png" alt></p>
<h3 id="面片减少"><a href="#面片减少" class="headerlink" title="面片减少"></a>面片减少</h3><p><img src="/images/2023-09-02-13-45-31.png" alt></p>
<p>不同数量三角形表现的物体效果。</p>
<h4 id="边坍缩方法"><a href="#边坍缩方法" class="headerlink" title="边坍缩方法"></a>边坍缩方法</h4><p>将一个边变为一个点。<br><img src="/images/2023-09-02-13-49-31.png" alt></p>
<p>使用该方法时，我们需要考虑的问题将点放在什么位置，以及坍缩哪些边。</p>
<p>我们使用二次误差度量方法来进行计算。</p>
<p>原理：计算新的点到原来的几个面的平方和最小的位置就是坍缩后顶点的位置。<br>下图为一个二维的效果展示。<br><img src="/images/2023-09-02-14-00-43.png" alt></p>
<p>如何选择坍缩的边呢？我们可以将每一条边的二次误差计算出来，然后选择最小的二次误差的边进行坍缩，然后计算坍缩后的边的二次误差，继续这个过程。<br>要实现上述方法，我们需要考虑使用一种数据结构来实现算法，让我们可以快速找到最小的二次误差，以及其影响的边。我们可以使用优先队列（堆）来对数据进行存储。</p>
<h2 id="阴影问题"><a href="#阴影问题" class="headerlink" title="阴影问题"></a>阴影问题</h2><h3 id="shadow-mapping"><a href="#shadow-mapping" class="headerlink" title="shadow mapping"></a>shadow mapping</h3><p>核心思想：如果点不在阴影里，但是可以看到这个点，那么这个点一定是受到光照且在视线中。利用这个思想，我们就可以做出阴影。</p>
<p>工作步骤：</p>
<ol>
<li>从光源看向场景，判断那些点可以被光线照射到，并记录这些点的深度。</li>
<li>从我们的摄像机看向场景，判断哪些点可以被看到，同时将这些点投影到光线记录的点并查看该点是否可以被光源和摄像机看到。如果该点可以被同时看到，那么就判定为场景，否则判定为阴影。<br><img src="/images/2023-09-02-14-21-30.png" alt></li>
</ol>
<p>工作流程图片：</p>
<p><img src="/images/2023-09-02-14-23-14.png" alt></p>
<p>光源能够看到的场如图所示，然后我们记录其深度图：</p>
<p><img src="/images/2023-09-02-14-23-45.png" alt></p>
<p>然后我们从相机进行点的映射：</p>
<p><img src="/images/2023-09-02-14-24-38.png" alt></p>
<p>图片为将看到的像素映射到光线的深度图后的效果，颜色越亮说明看到像素不受光照且距离光源距离较远。无色部分则代表该点可以被光源和相机同时看到。我们可以根据这个图来制作阴影。</p>
<p>使用该方法会出现很多问题：</p>
<ol>
<li>浮点数比较时很难获得相等的结果（因为精度问题）。常用的解决方法是设定一个范围，只要处于该范围内就判定其结果。或者设定一个偏差值，使得其较小位数影响变小（但是不能完美解决，上图的点就是这个原因产生的）。</li>
<li>shadow map本身需要有一个分辨率，如果使用小的分辨率，但是场景分辨率很高，那么会损失信息，发生走样。如果提高shadow map分辨率则会大大提高开销。</li>
<li>只能做硬阴影。</li>
</ol>
<p>就算有这些问题，但是shadow mapping技术还是具有极广泛的应用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/08/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/30/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A001/" class="post-title-link" itemprop="url">算法学习01</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-30 21:21:24" itemprop="dateCreated datePublished" datetime="2023-08-30T21:21:24+08:00">2023-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-16 10:14:46" itemprop="dateModified" datetime="2023-11-16T10:14:46+08:00">2023-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本栏记录一下这段时间做过的算法题目以及笔试遇到的算法题。算法我刷的题单是代码随想录，然后会记录一下遇到的新题。</p>
<h1 id="旧题复习"><a href="#旧题复习" class="headerlink" title="旧题复习"></a>旧题复习</h1><h2 id="二分查找："><a href="#二分查找：" class="headerlink" title="二分查找："></a>二分查找：</h2><p>题目链接 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<p>解决方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) </span><br><span class="line">    &#123;</span><br><span class="line">        int min = 0;;</span><br><span class="line">        int max = nums.size()-1;</span><br><span class="line">        while(min&lt;=max)</span><br><span class="line">        &#123;</span><br><span class="line">            int mid = min+(max-min)/2;</span><br><span class="line">            if(nums[mid] == target)</span><br><span class="line">            &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[mid]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                max = mid-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                min = mid+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>解决思路：<br>二分查找是一种分治的思想，将复杂的问题简化，在更小的区间里使用同样的方法进行计算。所以必须是有序的数据才可使用二分法，否则分割后无法获得更小的区间。每一次分割后对将搜索数组减小到目标可能存在的区间。这种搜索方法的时间复杂度可以达到O(logn)而一般的顺序遍历则复杂度为O(n)。</p>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>leetcode原题地址：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<p>解题思路：</p>
<p>原地删除数组中的数，这道题的思路是使用双指针法，第一个慢指针用来指向当前遍历到的位置，然后快指针用指向要需要的元素，当慢指针遇到了需要删除的元素时，移动快指针，直到快指针指向的元素是需要保留的元素，然后交换快慢指针的元素。同时快慢指针同时向前并继续上述步骤直到快指针指向空。期间我们只需要记录慢指针的移动次数，因为慢指针指向的就是我们需要保留的元素。</p>
<p>实现代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//快指针</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();<span class="comment">//总数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)<span class="comment">//i为慢指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[j]==val&amp;&amp;j&lt;nums.<span class="built_in">size</span>())<span class="comment">//如果快指针移动后还是指向需要删除元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                n--;<span class="comment">//也可以记录快指针运动的次数，这个是需要删去元素的数量</span></span><br><span class="line">                <span class="keyword">if</span>(j==nums.<span class="built_in">size</span>())<span class="comment">//快指针是否为空</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = nums[j];<span class="comment">//交换数据可以使用swap也可以直接覆盖值，因为删除的元素不需要保留</span></span><br><span class="line">            j++;<span class="comment">//同时走一次</span></span><br><span class="line">            <span class="keyword">if</span>(j==nums.<span class="built_in">size</span>())<span class="comment">//快指针是否为空</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;<span class="comment">//返回元素数量</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>学习视频链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cg411g7Y6/?vd_source=02049ce7fe76d9f1b0e50f98f5d785eb">https://www.bilibili.com/video/BV1cg411g7Y6/?vd_source=02049ce7fe76d9f1b0e50f98f5d785eb</a></p>
<p>简单的01背包问题：<br>给出n种物品，每一种物品只有一个，每个物品有自己的重量和价值，还有一个载重为m的背包，尽可能往背包种装载，问背包能装的最大价值是多少。<br>如果使用暴力解法，我们会法线时间复杂度非常高，一般使用回溯算法进行枚举。时间复杂度非常高一般为O(n²)。<br>使用动态规划的方法可以较好的解决该类问题。<br>做动态规划首先要设定一个dp数组。<br>这里我们创建一个二维的dp数组：<strong>dp[i][j]</strong></p>
<p>在这个dp数组中，i表示下标为0-i的物品。而从0-i中任意取物品，放入容量为j的背包中。</p>
<p>围绕上述的含义，我们继续来确定递推公式：</p>
<p><strong>我们知道dp数组的i代表的时物品编号，同时j为从0-i中放入小于等于j的重量的物品后的价值，那么我们可以知道如果我们的背包中不包括i，则所选数组应该为dp[i-1][j]。如果我们要放入物品，我们可以得到dp[i-1][j-weight[i]]+value[i]获得，如果能够放下，则取dp[i-1][j-weight[i]+value[i]]。否则选择之前的dp[i-1][j]。最终我们的递推公式为：dp[i][j] = max(dp[i-1][j-weight[i]]+value[i],dp[i-1][j])。（当j-weight[i]&lt;0时直接取dp[i-1][j]）</strong></p>
<p><strong>然后时我们dp数组的初始化，由上述内容可以看出，我们的递推方向是从左上到右下的过程来获取的。所以我们只需要初始化第一行和第一列即可。</strong></p>
<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>通过上述方法我们可以发现，二维数组其实是可以压缩成一维数组的。我们来看dp数组的意义。i代表了物品的编号，而j代表了在载重量为j的背包中能够保有的最大价值量。所以实际上i是可以略去的，因为物品的选择是可以被j来体现的，在j这个载重量下可以放入新的物体，那么该物体就可以放入并增加总价值；无法放入则不对价值造成影响，我们可以继续尝试放入其他的物品。</p>
<p>递推公式：<br><strong>dp[j] = max(dp[j-weight[i]]+value[i],dp[j]),如果无法放入的话直接取dp[j]</strong></p>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>这是一个可以用01背包思想来解决的问题。leetcode地址：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p>
<p>根据题目要求，如果我们可以将nums数组分割为两个一样的和的子集，那么返回true，否则为false。</p>
<p>分析题目，我们可以知道，由于nums是一个整数数组，如果nums数组的和的一半不为整数，那么必然是不能找到符合要求的两个子集的。所以第一步我们可以求数组nums的和，存在sum中，并判断是否复合一半为整数这个条件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">    sum+=nums[i];</span><br><span class="line"><span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sum/=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>经过这一步，我们就获取了我们需要求出的一个结果sum，只要我们的数组中有元素的和为sum，就可以返回true了。</p>
<p>这个求取元素和的过程我们可以使用01背包的思路来实现。首先我们要确定我们的dp数组，这里我们可以使用一维的或者二维的，由于一维比较省空间，所以我们选择一维数组。一维dp[j]数组的j代表了nums中可以放入的元素的和的最大值（其大小小于等于j）。</p>
<p>我们首先初始化一个数组，数组的长度为我们要求的sum的两倍，这样可以保证我们能将所有的nums遍历一遍并放入dp数组中，在将所有的nums放入dp数组中后，我们只需要查看dp[sum]是否等于sum,就可以判断该数组能否分割成两个和相同的子集了。</p>
<p>同时要注意一维01背包dp数组的遍历方法，在将元素放入dp数组时要反向遍历，否则会导致可放入元素重复放入。</p>
<p>具体工作代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum*<span class="number">2</span>,<span class="number">0</span>)</span></span>;<span class="comment">//设置dp数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)<span class="comment">//遍历nums的各个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = sum;j&gt;=nums[i];j--)<span class="comment">//判断元素可以在什么位置放入</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j-nums[i]]+nums[i],dp[j]);<span class="comment">//放入元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dp[sum]==sum)<span class="comment">//判断在和的一半的的位置是否放满，放满意味着可以将这些元素分成两个和相同的子集</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ximu"
      src="/logo/logo.png">
  <p class="site-author-name" itemprop="name">Ximu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ximu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
