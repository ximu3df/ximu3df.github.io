<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ximu3df.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ximu&#39;s Blog">
<meta property="og:url" content="http://ximu3df.github.io/page/2/index.html">
<meta property="og:site_name" content="Ximu&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ximu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://ximu3df.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ximu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ximu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/06/25/SPH%E5%86%8D%E6%B7%B1%E5%85%A5%E4%BB%A5%E5%8F%8AunityComputeShader%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/25/SPH%E5%86%8D%E6%B7%B1%E5%85%A5%E4%BB%A5%E5%8F%8AunityComputeShader%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">SPH再深入以及unityComputeShader学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 20:30:21" itemprop="dateCreated datePublished" datetime="2023-06-25T20:30:21+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:17" itemprop="dateModified" datetime="2023-08-31T22:44:17+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一段时间完成了SPH物理水的实现，这里记录一下自己在本次实现过程中所面临的问题以及学习路径和相关内容。</p>
<h1 id="Unity-Compute-Shader的学习"><a href="#Unity-Compute-Shader的学习" class="headerlink" title="Unity Compute Shader的学习"></a>Unity Compute Shader的学习</h1><p> 由于本次实现是基于unity来实现的，那么就要考虑在unity中的具体实现方式。由于SPH是通过周围粒子的信息来获取单个粒子的信息的，这个过程就需要大量的计算（因为为了保证视觉效果可能就需要使用大量的粒子来进行模拟，随之而来的就是大量的计算）。在unity中，一般的C#脚本是通过cpu来进行计算的，所以面对大量的计算工作，可能会导致帧率较低。而在unity中，提供了一个名为comoute shader的着色器，该着色器可以调用gpu资源来进行计算，这让SPH物理水的粒子计算有了可能性。</p>
<p>为此，我学习了unity中compute shader的相关知识以及使用。参考的文章如下：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368307575">Compute Shader的基础介绍与使用</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/368307575">Unity基础-5,Compute Shaders</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/cn/current/Manual/UnityManual.html">unity官方文档</a></p>
<p>这里总结一下自己所学到的内容：（学得比较浅）</p>
<h2 id="什么是compute-shader？"><a href="#什么是compute-shader？" class="headerlink" title="什么是compute shader？"></a>什么是compute shader？</h2><p>unity中的计算着色器是和DirectX 11 DirectCompute紧密配合的。在我看来，unity通过其脚本将打包好的要处理的数据传入计算着色器中（这个过程其实就是将数据存储在gpu上），而计算着色器则通过DirectCompute来调用gpu从而完成相关的运算（使用的是HLSL）。</p>
<p>那么gpu编程和一般的编程过程有什么具体的区别呢？</p>
<p>我认为有以下几个不同点：</p>
<ol>
<li>由于gpu可以提供很多的线程，所以是并行编程，但是每一次计算量不宜过大，因为本身gpu提供的线程的处理能力都远不如cpu，但是其优点是可以同时进行大量的计算。如果使用cpu则会使得每一帧的运算时间过长，难以达到实时的效果。</li>
<li>在代码编写的逻辑上也有一定的区别，以循环逻辑为例：cpu编程的过程中使用循环的方式是设置一个结束条件，然后逐步运行循环中的内容。但是compute shader在处理多次循环时一般会考虑使用等数量的线程来进行运算。例如我需要运行100次循环，gpu会使用100个线程使用一次计算时间来完成计算，而cpu则要进行100次计算。</li>
<li>同时对多个数据处理，如果有迭代的要求，则可能会出现错误数据，所以原子操作在compute shader中是十分重要的。但是cpu中由于是顺序进行，所以迭代的实现没有那么多需要考虑的。</li>
</ol>
<p>还有很多其他不同点，但是了解了以上几个不同点之后我认为就已经足够实现本次的工作了。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="compute-shader部分"><a href="#compute-shader部分" class="headerlink" title="compute shader部分"></a>compute shader部分</h3><p>unity中的compute shader使用的是HLSL语言，同时还需要考虑使用C#脚本对compute shader进行数据的设置和调用着色器。</p>
<p>如果只是考虑使用compute shader进行数据的计算，那么只是用C#和compute shader就足够了，但是如果需要对网格进行渲染，还需要一般shader来进行辅助。</p>
<p>具体来看一下如何使用：</p>
<p>首先是compute shader部分，在unity中创建一个compute shader后就可以获得如下的一个模板：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> kernel CSMain</span></span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line"></span><br><span class="line">[<span class="meta">numthreads(8,8,1)</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSMain</span> (<span class="params">uint3 id : SV_DispatchThreadID</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Result[id.xy] = float4(id.x &amp; id.y, (id.x &amp; <span class="number">15</span>)/<span class="number">15.0</span>, (id.y &amp; <span class="number">15</span>)/<span class="number">15.0</span>, <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看一下各个部分的含义：</p>
<p>首先是#pragma kernel CSMain，这个位置为一个可调用内部函数的声明，在外部想要使用compute shader中的函数，就需要先声明一个核函数。一个compute shader文件中至少要有一个核函数，否则无法工作。</p>
<p>然后是RWTexture2D<float4> Result;这是一个可读写的2d纹理对象（前面的RW代表了可读写，意味着我们可以在C#脚本中通过相关的方法来对该缓存中的数据进行读写）。我们也可以定义其他的全局变量或者是缓存区来方便我们的数据处理。</float4></p>
<p>最后是函数部分，在CSMain函数的上面有一段[numthreads(8,8,1)]，这个是我们的线程数量，这一部分可以参考微软的文档：<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/sm5-attributes-numthreads">numthreads</a></p>
<p>简单来说numthreads记录了一个线程组中的线程数量。三个参数意味着是以三维的方式来对线程进行编号记录的。但是其中也提供了很多的访问方式，例如上面代码中的参数部分：uint3 id : SV_DispatchThreadID，<strong>uint3</strong>我们都是知道是无符号整型的三维向量，而后面的宏又代表了什么呢？<strong>SV_DispatchThreadID</strong>实际上是我们获取线程编号的一种方式，其存储的数据是线程组的编号的xyz分别乘上整个一个线程组中的各个维度的线程总数的xyz再加上上述参数id的xyz。</p>
<p>具体可参考下图：<br><img src="/images/2023-06-26-19-08-45.png" alt><br>    来微软自官方文档</p>
<p>同样还提供了其他的宏让我们更好的进行相关遍历操作和线程选择。具体可以查看下图：<br><img src="/images/2023-06-26-19-57-43.png" alt></p>
<p>通过这些方式，我们就可以选择需要的线程查询方式来对文件工作线程的工作进行设计了。</p>
<p>CSMain中，我们就可以进行我们需要的工作了。</p>
<h3 id="C-部分"><a href="#C-部分" class="headerlink" title="C#部分"></a>C#部分</h3><p>在C#中，我们需要做的主要是创建一个ComputeShader类的实例，然后通过该对象的相关操作，传入数据缓存，调用核函数，然后使用你经过计算着色器计算后的数据即可。</p>
<p>大概可以分为以下几步：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComputeShader computeShader;<span class="comment">//计算着色器实例</span></span><br><span class="line"><span class="built_in">int</span> CSMain;</span><br><span class="line">CSmain = computeShader.FindKernel(<span class="string">&quot;CSMain&quot;</span>);</span><br><span class="line">computeShader.Dispatch(CSMain, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>上述过程为创建一个计算着色器实例，创建一个用于存储核函数句柄的整数，然后通过FindKernel函数获得对应核函数的句柄，最后通过Dispatch函数来对计算着色器中的方法进行调用。第一个参数为调用函数的句柄，后面三个为线程组的标号，使用的是一个三维向量来表示。具体可以参考前文中的<strong>numthreads</strong>的说明。简单来说，此处定义了有多少组线程组，而numthreads则是定义了一个线程组有多少个线程。例如上面代码中（包括计算着色器中的代码），总共有10*10*10*8*8*1个线程，其中10*10*10为线程组的数量，而8*8*8为一个线程组中的线程数量。这两个部分直接影响的是计算着色器中对应函数的参数可以获得的数据。（这里不能开辟太多的线程，毕竟GPU线程数量是有限的，具体数据可以查看英伟达官网）。</p>
<p>通过上述步骤，就可以完成一次compute shader函数的调用了。但是这仅仅是调用了相关函数，我们要如何通过计算着色器获取我们需要的数据呢？</p>
<p>这里就要使用我们的数据缓存了，unity中提供了ComputeBuffer类来完成cpu与gpu之间的数据交换。ComputeBuffer是一个用来存储一组数据的缓存，我们可以通过在cpu中定义需要存储的数据，然后放入buffer中，该数据就可以在gpu中使用。</p>
<p>具体操作可参考如下代码：<br>例如我们要创建一个100个整形的缓存<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComputeBuffer buffer;</span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">100</span>];</span><br><span class="line">buffer = <span class="keyword">new</span> ComputeBuffer(<span class="number">100</span>,<span class="keyword">sizeof</span>(<span class="built_in">int</span>));</span><br><span class="line">buffer.SetData(arr);</span><br><span class="line">computeShader.SetBuffer(CMain,<span class="string">&quot;_buffer&quot;</span>,buffer);</span><br></pre></td></tr></table></figure><br>这样我们就能够创建一个数据缓存了，而compute shader中，则只需要创建对应的用于存储的对对象即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RWStructuredBuffer&lt;<span class="built_in">int</span>&gt; _buffer;</span><br></pre></td></tr></table></figure>
<p>同时需要注意，在需要使用到缓存的函数中使用SetBuffer。例如我们上述代码中，还有其他核函数使用了_buffer，那么只使用一次SetBuffer就会报错，需要取得对应句柄再次SetBuffer。</p>
<p>如果要获得处理后的数据可以使用对应的buffer对象中所包含的函数GetData来将缓存中的数据读取到cpu中。</p>
<p>以上便是简单的Compute Shader使用方法了，之后其他的具体使用会在具体实现的过程中来详细的说明。</p>
<h1 id="SPH的再学习"><a href="#SPH的再学习" class="headerlink" title="SPH的再学习"></a>SPH的再学习</h1><p>之前有过一篇文章，是通过别人的文章学习并记录的，这里给出参考博客的原地址：<a target="_blank" rel="noopener" href="https://www.thecodeway.com/?p=83">https://www.thecodeway.com/?p=83</a></p>
<p>但是在具体的实现过程中还是有很多SPH知识相关的问题出现。所以这里再次记录学习过程：</p>
<h2 id="整体原理概述"><a href="#整体原理概述" class="headerlink" title="整体原理概述"></a>整体原理概述</h2><p>SPH方法其实是将液体描述为由许多微小的粒子组成的整体（微原法），对每一个粒子进行受力分析，从而获得粒子的速度加速度。其特点是使用非网格的方式，使得比较适合实现流体。</p>
<p>粒子的运动过程中一般会受到以下几种力的影响重力（属于外力）、粘滞力、压力。SPH的求取过程其实就是在求每一个粒子受到的粘滞力、压力，然后通过f=ma来求取位置信息，最后逐帧更新，从而达到流体动画的播放效果。</p>
<h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>在SPH中，我们的主要工作是计算粘滞力和压力（重力不变的情况下）。具体的计算公式的推导如下：</p>
<p>水粒子在整体中主要受到外力和内部力两种类型的力影响。外力我们暂且不论，首先考虑内部力。在SPH的思想中，每一个粒子受到的内部力主要是受到周围粒子的影响。</p>
<h2 id="实现公式的推导"><a href="#实现公式的推导" class="headerlink" title="实现公式的推导"></a>实现公式的推导</h2><p>可以查看上一篇文章，或者参考文章：<a target="_blank" rel="noopener" href="https://www.thecodeway.com/?p=83">https://www.thecodeway.com/?p=83</a></p>
<h2 id="实现的思路"><a href="#实现的思路" class="headerlink" title="实现的思路"></a>实现的思路</h2><p>这一步将会着重说明具体的实现思路：</p>
<p>首先要实现SPH，要考虑需要使用的数据。首先必须有的是每一个粒子的位置信息，其次计算每一个粒子的位置信息是基于速度与加速来进行计算的。那么最基本的三个数据就是粒子的位置（三个float），速度（三个float），加速度（三个float）。粒子的很多数据计算会使用到密度，所以这里需要一个密度数组来存储每一个粒子的密度（一个float）。</p>
<p>同时由于考虑到计算中更好的遍历周围的粒子（不可能查找每一个粒子的时候把所有粒子都遍历一遍）所以我们就需要找到一个方法来方便遍历的。这里采用一个空间分割的方法，将空间分割为大小相等块，然后对每个块中的粒子进行记录，记录后对每个粒子进行访问的时候，就将自身所在空间格的周围的27个格子（立方体）中的粒子进行遍历，这样的话就可以减少查找周围粒子的时间。所以我们还需要一个哈希表。转换公式就是：哈希表索引 = 位置x值 + 位置y值*空间长 + 位置z值*空间总长的平方。这样的话我们就需要一个大小为空间格子总数的数组来存储数据（int类型）。同时还需要一个数组用于存储粒子的索引值，这个数组的大小等于空间格子数*每个格子可搜索数据数的最大值。每次查找的时候只需要通过哈希表索引+偏差值，就可以查找到一个空间格中存在的粒子的索引了。</p>
<p>以下为一个2d例子：</p>
<p><img src="/images/2023-06-30-14-29-58.png" alt></p>
<p>空间分为了9个格子，例如当前遍历的是4号格子中的白色粒子，那么就需要对0-8号空间格进行遍历。其中存储的数据结构格式如下：<br><img src="/images/2023-06-30-14-41-05.png" alt></p>
<p>给出了前三个空间的数据存储方式，具体为基于数组实现的哈希表，每个空间格能存储的粒子数量为5个。</p>
<p>通过上述数组，然后进行相应遍历即可实现空间分割后的数据。</p>
<h2 id="实现流程以及效果："><a href="#实现流程以及效果：" class="headerlink" title="实现流程以及效果："></a>实现流程以及效果：</h2><p>每一帧的工作流程如下：<br><img src="/images/2023-06-30-14-59-34.png" alt></p>
<p>目前实现效果展示：<br><img src="/images/SPH效果.gif" alt></p>
<p>以上为8000个粒子的模拟效果实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/21/SPH%E6%B3%95%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/SPH%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">SPH法学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-21 16:33:03" itemprop="dateCreated datePublished" datetime="2023-05-21T16:33:03+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:16" itemprop="dateModified" datetime="2023-08-31T22:44:16+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SPH法学习记录"><a href="#SPH法学习记录" class="headerlink" title="SPH法学习记录"></a>SPH法学习记录</h1><p>参考文章：<a target="_blank" rel="noopener" href="https://www.thecodeway.com/?p=83">https://www.thecodeway.com/?p=83</a></p>
<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>SPH（smoothed-particle hydrodynamics）光滑粒子流体动力学，是一种用于模拟连续介质动力学的计算方法，如固体力学和流体流动。 它由Gingold和Monaghan（1977）和Lucy（1977）提出，最初用于天体物理问题。 此方法已被用于许多研究领域，包括天体物理学，弹道学，火山学和海洋学。 它是一种无网格的拉格朗日方法（即坐标系与流体一起移动），并且方法的分辨率可以容易地相对于诸如密度的变量进行调整。（来源于维基百科）</p>
<p>其特点是使用拉格朗日视角来对流动物进行观察，也就是对流动的东西建立坐标系，而不是如欧拉视角一般直接建立一个世界坐标系，这样做的好处是可以更加快速的对我们抽象离散化的流体粒子进行处理，而不需要过多的坐标转换。</p>
<h2 id="数学基础："><a href="#数学基础：" class="headerlink" title="数学基础："></a>数学基础：</h2><ol>
<li><p>标量场</p>
<p>如果空间中每一个位置都可以用一个属性（标量）来表示，那么这样的空间就是标量场。</p>
</li>
<li><p>矢量场</p>
<p>如果空间中每一个位置都可以用一个向量来表示，那么这样的空间就是矢量场。</p>
</li>
<li><p>偏导数：</p>
<p>多元函数Z = f（X，Y）表示的是一个三维的曲面，对x偏导就是该曲面在x轴上的变化率，对y偏导这是在y轴上的变化率。对应到物理上就是一个物理系统里，某一参数的变化，引起的物理量（函数）的变化。</p>
</li>
<li><p>哈密顿算子：</p>
<p>∇（哈密顿算子），是流体力学中十分重要的一环。∇的定义如下：</p>
<script type="math/tex; mode=display">
∇ = \frac{d}{dr}</script><p>多维形式的表示为：</p>
<script type="math/tex; mode=display">
∇ = \frac{d}{dx}\vec{x} + \frac{d}{dy}\vec{y}+\frac{d}{dz}\vec{z}</script><p>该算子的作用为：<br>直接作用于函数（无论是标量还是矢量）是用于求取该函数的梯度，如果其参数是三维向量则表示求取旋度，如果为二维向量则是求取散度。</p>
</li>
<li><p>拉普拉辛算子：</p>
<p>二阶微分算子</p>
<script type="math/tex; mode=display">
∇^2A = \frac{d^2}{dx^2}\vec{x} + \frac{d^2}{dy^2}\vec{y}+\frac{d^2}{dz^2}\vec{z}
 \\
其中A为：A = f(x,y,z)</script><p>拉普拉辛算子的物理意义是一个场变量的梯度的散度，向量场中经过哈密顿算子的计算之后可以获得</p>
</li>
</ol>
<h2 id="粒子受力分析："><a href="#粒子受力分析：" class="headerlink" title="粒子受力分析："></a>粒子受力分析：</h2><p> SPH算法的基本设想，就是将连续的流体想象成一个个相互作用的微粒，这些例子相互影响，共同形成了复杂的流体运动，对于每个单独的流体微粒，依旧遵循最基本的牛顿第二定律。</p>
<script type="math/tex; mode=display">F = ma</script><p> 在流体中，质量由流体单元密度决定</p>
<script type="math/tex; mode=display">F = ρa</script><pre><code>这里用密度代替了质量，由于使用了密度代替了质量，所以力的量纲转换为：
</code></pre><script type="math/tex; mode=display">F = ML^{-2}T^{-2}</script><p>之后我们来判断每一个粒子中所受到的力：</p>
<script type="math/tex; mode=display">F^{合外力} = F^{外部作用力}+F^{内部压力差}+F^{内部速度差}</script><p>外部作用力一般指的是重力：</p>
<script type="math/tex; mode=display">F = ρg</script><p>内部压力差一般是指流体内部由于压力所造成的力，该值为压力场中的梯度，方向为压力高的方向指向方向低的方向。由于∇乘上一个向量场可以表示其梯度，所以公式为：</p>
<script type="math/tex; mode=display">F = -∇p</script><p>内部速度差是由粒子间的速度差引起的，快的粒子会阻隔慢的粒子，这个部分是由于粘滞系数μ所影响的：</p>
<script type="math/tex; mode=display">F = μ∇^2u</script><p>将上述的公式带入可以获得如下结果：</p>
<script type="math/tex; mode=display">\vec{a} = \vec{g} - \frac{∇p}{ρ} + \frac{μ∇^2\vec{u}}{ρ}</script><h2 id="光滑核函数"><a href="#光滑核函数" class="headerlink" title="光滑核函数"></a>光滑核函数</h2><p>SPH函数中的光滑核概念：</p>
<p>粒子的力会扩散影响到周围粒子，并且会随着距离的增大而减小。</p>
<p>这种随着距离而衰减的函数被称为“光滑核”函数，最大影响半径为“光滑核半径”。</p>
<p>假设在流体中某个点：</p>
<script type="math/tex; mode=display">\vec{r}</script><p>其周围有数个粒子：</p>
<script type="math/tex; mode=display">\vec{r_1} \vec{r_2} \vec{r_3} \vec{r_4}……\vec{r_j}</script><p>则这个位置的累加属性为：<br><img src="/images/image.png.png" alt></p>
<p>其中A是某一种要累加的属性，m和ρ是质量和密度，r是粒子的位置，h光滑核的半径，W就是光滑核函数。</p>
<p>光滑核函数有两个重要的属性分别为：</p>
<p>偶函数和规整函数（积分为1）</p>
<h3 id="SPH的推导过程："><a href="#SPH的推导过程：" class="headerlink" title="SPH的推导过程："></a>SPH的推导过程：</h3><p>跟具上述的受力分析，我们可以得到某个位置的加速度为：</p>
<script type="math/tex; mode=display">a(\vec{r}) = \vec{g} -\frac{∇p(r_i)}{ρ(r_i)} + \frac{μ∇^2\vec{u}(r_i)}{ρ(r_i)}</script><p> 对于SPH算法来说，基本流程就是这样，根据光滑核函数逐个推出流体中某点的密度，压力，速度相关的累加函数，进而推导出此处的加速度，从而模拟流体的运动趋势.</p>
<p> 在此之前，首先要说明一下什么是光滑核函数:</p>
<p> <strong>光滑核函数可以被理解为一种在一定光滑长度h范围内其他临近粒子对研究粒子影响程度的权函数</strong></p>
<p> <strong>密度的推导</strong></p>
<p> 用密度ρ代替A，可以得到:</p>
<script type="math/tex; mode=display">ρ(r_i) = \sum ρ_j\frac{m_j}{ρ_j}W(\vec{r_i}-\vec{r_j},h)

 =\sum m_jW(\vec{r_i}-\vec{r_j},h)</script><p> 其中的W函数则使用poly6光滑核来实现：</p>
<p> <img src="/images/2023-05-23-12-00-54.png" alt></p>
<p> 其中三维空间下的K是由下述公式所得：</p>
<p> <img src="/images/2023-05-23-12-02-54.png" alt></p>
<p> 带入上述公式后，可以得到密度公式为：</p>
<p> <img src="/images/2023-05-23-12-04-18.png" alt></p>
<p> <strong>压力的推导</strong></p>
<p>用压力来代替A可以获得以下公式</p>
<script type="math/tex; mode=display">F_i = -\sum p_j\frac{m_j}{ρ_j}∇W(\vec{r_i}-\vec{r_j},h)</script><p>但是由于两个不同位置的粒子所收到的压强是不相等的，所以这里使用平均值来计算压强：</p>
<script type="math/tex; mode=display">F_i = -\sum (p_j+p_i)\frac{m_j}{2ρ_j}∇W(\vec{r_i}-\vec{r_j},h)</script><p>同时此处的W也要选择一个核函数来进行计算，这里使用的是Spiky函数：</p>
<p><img src="/images/2023-05-23-12-31-08.png" alt></p>
<p>在三维情况下的k为：<br><img src="/images/2023-05-23-12-31-43.png" alt></p>
<p>带入上述式子有：</p>
<p><img src="/images/2023-05-23-12-32-06.png" alt></p>
<p><strong>粘度的推导</strong><br>把粘相关力替换A有：</p>
<script type="math/tex; mode=display">F_i = μ\sum u_j\frac{m_j}{ρ_j}∇^2W(\vec{r_i}-\vec{r_j},h)</script><p>同压力，这里也有不平衡问题，为了解决这个问题，我们要使用相对速度来求解：</p>
<script type="math/tex; mode=display">F_i = μ\sum (u_j-u_i)\frac{m_j}{ρ_j}∇^2W(\vec{r_i}-\vec{r_j},h)</script><p>此处我们使用的光滑核函数如下：</p>
<p><img src="/images/2023-05-23-12-38-23.png" alt></p>
<p>三维情况下的k为：</p>
<p><img src="/images/2023-05-23-12-43-38.png" alt></p>
<p>带入公式后：</p>
<p><img src="/images/2023-05-23-12-43-59.png" alt></p>
<p><strong>将三个部分带入原来的公式</strong>：</p>
<p><img src="/images/2023-05-23-12-44-21.png" alt></p>
<h2 id="自己的实现思路"><a href="#自己的实现思路" class="headerlink" title="自己的实现思路"></a>自己的实现思路</h2><p>上述内容为理论基础。现在将尝试实现。</p>
<p>首先考虑用于实现的工具，这里尝试使用unity来进行实现。但是粒子运算需要大量的算力，所以这里将考虑使用unity提供的GPU计算着色器，compute shader。</p>
<p>之后会更新以下compute shder的学习过程和SPH的实现过程的文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/18/games106%E7%AC%94%E8%AE%B01-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/18/games106%E7%AC%94%E8%AE%B01-3/" class="post-title-link" itemprop="url">games106笔记1-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-18 14:46:51" itemprop="dateCreated datePublished" datetime="2023-05-18T14:46:51+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:14" itemprop="dateModified" datetime="2023-08-31T22:44:14+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Games106-Note-1-3"><a href="#Games106-Note-1-3" class="headerlink" title="Games106 Note 1-3"></a>Games106 Note 1-3</h1><h2 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h2><p>整个课程的主要内容：</p>
<p><strong>计算机图形的绘制，应用领域：设计、影视、游戏、艺术、可视化等。</strong></p>
<p>跟流水线相关的应用领域主要是游戏（因为需要实时的渲染交互）</p>
<p>固定的绘制流水线：</p>
<p>图片 = F（几何，纹理，光照，<strong>着色器</strong>）</p>
<p>有了着色器之后，流水线就是可编程的了。着色器就是使用一种语言来对流水线进行定制化的更改，从而获得我们需要的图片绘制效果。</p>
<p>一般流程如下：<br><img src="/images/2023-05-18-15-16-03.png" alt></p>
<pre><code>这里有一个转变就是顶点着色器后到片段着色器前的阶段，

也就是光栅化阶段，这个过程使得我们的输入变为了一个

屏幕数组下的像素数据。
</code></pre><p>在上述内容中，可以编程的部分为：<br><strong>顶点着色器、片段着色器</strong>。</p>
<p>现代绘制流水线：<br><strong>Vulkan</strong></p>
<p>优点：由于OpenGl对自己的驱动层添加的内容过多，造成的负担越来越大。由此Vulkan将自己的驱动层进行了大量的修改和删除。由此有了更简单的开发api并且更具鲁棒性。</p>
<p>作业部分：<br>环境运行的配置</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/17/L%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/17/L%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">L系统学习记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-17 15:37:50" itemprop="dateCreated datePublished" datetime="2023-05-17T15:37:50+08:00">2023-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:15" itemprop="dateModified" datetime="2023-08-31T22:44:15+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="L系统学习"><a href="#L系统学习" class="headerlink" title="L系统学习"></a>L系统学习</h1><p>该文章内容来自我大三的一门动画原理课程，主要记录自己学习该内容的一些思考以及尝试的应用。如果可能以后会有相关作品会使用到该系统。</p>
<h2 id="基于语法的造型技术"><a href="#基于语法的造型技术" class="headerlink" title="基于语法的造型技术"></a>基于语法的造型技术</h2><p>首先我们要说明一种基于语法的造型技术，这种技术主要是通过使用字符串来表示绘图的规则。<br>现在我们可以举一个例子：</p>
<ol>
<li>F：表示在当前位置画一条长为k的直线，k是由用于事先定好的数值。表示线段的基本长度。</li>
<li>+：表示逆时针旋转一个α角，该角度是由用户事先定好的数值。</li>
<li>-：表示顺时针旋转一个α角。</li>
<li>[：表示暂时保存当前的画图状态</li>
<li>]：表示提取出保存的画图状态。 “[”和<br>“]”要成对的出现。</li>
</ol>
<p>确定了上述的内容，就可以通过字符串来绘制图像了。<br>假设我们现在设定了一个字符串为：<strong>FF+F</strong><br>就会得到如下的图像：<br><img src="/images/2023-05-17-16-10-16.png" alt></p>
<p>又如：<strong>FF[+F][-F]</strong><br>可以生成的图像如下：</p>
<p><img src="/images/2023-05-17-16-21-04.png" alt></p>
<h2 id="L系统"><a href="#L系统" class="headerlink" title="L系统"></a>L系统</h2><p>说明了基于语法的造型技术之后，我们就可以来开始说明什么是L系统了。</p>
<p>L-系统指美国生物学家Lindenmayer A. 提<br>出的研究生物形态与生长的描述方法。后来<br>Smith等人将L系统引进图形学，形成一类自<br>然景物模拟的有效方法。</p>
<p>L系统在模拟树叶、微生物形态、树枝等方面有较好的效果。</p>
<p>L系统相较于一般的基于语法的造型技术有什么差别呢？具体来说就是L系统是增加了迭代过程的基于语法的造型技术。</p>
<p>一般来说，L系统的定义如下：</p>
<p>G＝｛V,S,ω,P},</p>
<p>V:变量符号集合</p>
<p>S：常量符号集合</p>
<p>ω：初始状态串</p>
<p>P：产生式规则</p>
<p>这里说明一下什么是产生式规则：</p>
<p>产生式规则其实就是一种映射的关系，例如我有一个产生式X-&gt;Y，那么我在以下这个字符串中进行一次迭代就会有：</p>
<p><strong>FXFF+ -&gt; FYFF+</strong></p>
<p>如果我有两个关系是X-&gt;FY+，以及Y-&gt;XX，我们使用这两个规则进行迭代，那么在以下字符串中进行一次迭代就会获得：</p>
<p><strong>X -&gt; FXX+</strong></p>
<p>变量符号集合就是我们在整个过程中会使用的符号，常量即是开始工作时定义的数据，初始状态串（也叫公理）就是我们开始迭代的第一代。</p>
<p>通过上述的系统，我们可以来设计我们需要模拟的物品的变化规则。</p>
<h2 id="个人对于L系统使用"><a href="#个人对于L系统使用" class="headerlink" title="个人对于L系统使用"></a>个人对于L系统使用</h2><p>学习L系统的目的主要是为了去完成3d动画原理和制作这门课程的课程设计。个人认为L系统的原理简单但是精妙，可能会使用这个配合图形学相关知识去实现光照对树木生长影响的模拟动画，并且会尝试利用这个思路来实现一些游戏的视觉效果，从而利用到虚拟现实课程的课程设计上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/17/games101%E7%AC%94%E8%AE%B04-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/17/games101%E7%AC%94%E8%AE%B04-6/" class="post-title-link" itemprop="url">games101笔记4-6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-17 10:17:18" itemprop="dateCreated datePublished" datetime="2023-05-17T10:17:18+08:00">2023-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:11" itemprop="dateModified" datetime="2023-08-31T22:44:11+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Games101-Note-4-6"><a href="#Games101-Note-4-6" class="headerlink" title="Games101 Note 4-6"></a>Games101 Note 4-6</h1><h2 id="第四课"><a href="#第四课" class="headerlink" title="第四课"></a>第四课</h2><p>上节课补充内容：</p>
<p>二维旋转变化的齐次坐标中，旋转一个负角度等于旋转这个正角度的的矩阵的逆矩阵。举证的逆等于其转置，称之为正交矩阵。</p>
<h3 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h3><p>在三维的变换中，用于缩放变换和平移变换的四阶矩阵与二阶无异，区别比较大的是旋转操作。</p>
<p>在三维空间中，我们对一个旋转矩阵进行分析，会发现围绕一个轴旋转时，主要是由另外两个轴的坐标变化来实现的。</p>
<p>三个轴旋转的矩阵如下图：</p>
<p><img src="/images/2023-05-17-10-35-56.png" alt><br><img src="/images/2023-05-17-10-39-03.png" alt></p>
<p>那么如何获得一般的旋转方式呢？对于任意一种无法知道过程的旋转，我们可以用围绕xyz轴三个的旋转来表示，这就是欧拉角（Euler angles）</p>
<h4 id="罗德里格斯旋转公式"><a href="#罗德里格斯旋转公式" class="headerlink" title="罗德里格斯旋转公式"></a>罗德里格斯旋转公式</h4><p>该公式用于求一个向量朝着指定轴进行旋转得到一个新角度的向量。</p>
<p>具体的推导思路是：通过将围绕轴旋转的向量分解为两个方向的向量（分别是垂直于旋转轴和平行与旋转轴），再对两个向量通过与旋转轴的叉乘建立对应旋转平面的基向量，并使用三角函数进行表示旋转后的两个方向的向量，并合成为原来的合成后的向量。</p>
<p><img src="/images/2023-05-17-11-11-32.png" alt></p>
<blockquote>
<p>n为旋转轴，α为旋转角度</p>
</blockquote>
<h3 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h3><p>为了使得三维场景显示成二维图片，我们需要视图变换。</p>
<p>场景中物体的变换一般称为模型变换，然后我们找到一个位置来观察需要显示的内容的变换称为视图变换，最后要进行投影变换，让视窗的内容变为一张图片。</p>
<p>视图变换的具体工作：</p>
<p><strong>摆放我们的照相机</strong>，摆放要如何定义呢？</p>
<ol>
<li>相机的位置</li>
<li>观看的朝向</li>
<li>相机的向上的方向，用于控制相机的旋转</li>
</ol>
<p>有了定义的内容，我们要怎么去实现呢？</p>
<p><img src="/images/2023-05-17-11-36-28.png" alt></p>
<blockquote>
<p>一般我们的定义方法，将相机放在（0，0，0）的位置，观看方向为-z方向</p>
</blockquote>
<p>通过一个矩阵来对摄像机进行变换：</p>
<script type="math/tex; mode=display">
M_v = R_vT_v</script><p>T矩阵用于平移，R矩阵用于旋转。</p>
<p><img src="/images/2023-05-17-12-02-05.png" alt><br><img src="/images/2023-05-17-12-01-47.png" alt></p>
<p>R矩阵的求取方法是通过反求的方式，由于我们需要服从任意位置变化到原点，这个过程是不好求的以x为例：</p>
<p>你的x轴坐标可能是（6.1，8.4，3）我们要转到（1，0，0）这个求取过程是非常麻烦的，但是我们从（1，0，0）到（6.1，8.4，3）确是较为简单的，所以我们可以用逆矩阵的方式来处理（旋转矩阵是正交矩阵）。</p>
<p><strong>在对摄像机进行变换后，要让场景中的所有对象进行同样的变换。</strong></p>
<h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><p>两种变换方式：</p>
<ol>
<li>正交</li>
<li>投影</li>
</ol>
<p>两者的差别：有无透视关系。</p>
<p><img src="/images/2023-05-17-12-11-05.png" alt></p>
<h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>正交投影的过程是将场景中的物体映射到一个标准状态。</p>
<p>具体经过的过程是：</p>
<ol>
<li>将物体移到原点</li>
<li>将物体缩放到标准大小</li>
</ol>
<p><img src="/images/2023-05-17-12-25-25.png" alt></p>
<p><img src="/images/2023-05-17-12-27-49.png" alt></p>
<h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p><img src="/images/2023-05-17-12-39-04.png" alt></p>
<p>正交投影的过程是将场景中的物体映射到一个具有大小距离变化的状态。</p>
<p>具体经过的过程是：</p>
<ol>
<li>将物体放入视锥体之中</li>
<li>再做一遍正交投影</li>
</ol>
<p>放入视锥体的过程可以通过线性变换来实现，如下图：</p>
<p><img src="/images/2023-05-17-12-42-43.png" alt></p>
<p>我们以z轴上观察的透视矩阵为例：</p>
<p>根据相似三角形，我们可以通过y’=n*y/z的线性变化来改变x轴和y轴的坐标。<br>由此我们可以得到如下的表达式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x\\
y\\
z\\
1
\end{bmatrix}
=
\begin{bmatrix}
xn/z\\
yn/z\\
?\\
1
\end{bmatrix}
=
\begin{bmatrix}
xn\\
yn\\
?\\
z
\end{bmatrix}</script><p>由此我们就求出了xy的坐标，之后要考虑z轴的坐标了。</p>
<p>z的坐标其实很简单在近平面和远平面上，相当于构筑了一个x、y两个变量关于z的线性函数，那么当变化量为n（f）时，z的值就可以是n（f）。由此我们点可以表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
xn\\
yn\\
n^2\\
n
\end{bmatrix}</script><h2 id="第五课"><a href="#第五课" class="headerlink" title="第五课"></a>第五课</h2><p>当我们将物体进行视图变换、投影变换后，我们就需要将我们想要投影的图像显示在二维的屏幕上（在图形学中，屏幕被当作时一个二维数组处理），屏幕是一个典型的光栅化设备（Rasterize），而把场景内容绘制在屏幕上的过程就是光栅化过程。每一个栅格我们称之为像素（picture element，简写为Pixel），像素中会保存颜色信息等，例如灰度图像就是0~255的数字，而rgb形式的彩色像素则是用三个0~255的数字来存储（不仅于此，还可能存储其他信息）。</p>
<p>在games101的课程中，将使用使用如下的规则来定义栅格：<br><img src="/images/2023-05-18-12-37-57.png" alt></p>
<p>当到达这一步骤时，我们的输入就变成了一个2<em>2</em>2且中心在原点的立方体空间信息。但是这依然是三维的信息，我们要如何将三维的空间转化到二维屏幕呢？</p>
<p>这个过程的具体过程如下：</p>
<ol>
<li><p>先忽略z轴，将xy轴方向上的信息大小缩放到屏幕的大小，例如x轴就缩放为宽，y轴就缩放为高。同时还要将（-1，-1）的点移动到屏幕坐标系的原点位置，具体的变换过程如下矩阵：</p>
<script type="math/tex; mode=display">[-1,1]^2的二维面变化到[0,width]x[0,height]的二维面</script><p><img src="/images/2023-05-18-12-45-03.png" alt></p>
</li>
<li><p>将我们场景中的面片信息变为像素显示在屏幕上。</p>
<p>这里主要讲解了各种类型的显示设备，在大二图形学课程中已经学习，不做记录。</p>
<p>我们三维场景中的物体一般是由三角形面片组成的网格模型（使用三角形是因为三角形是最基础的多边形、多边形可以拆成三角形、三角形内部一定是平面的、三角形内部和外部定义得非常清楚）</p>
<p>有了三角形面片的存在，我们只需要对各个三角形进行光栅化就可以了：</p>
<p><img src="/images/2023-05-18-13-07-27.png" alt></p>
<p>一个比较简单的方法：<br>采样：将一个函数离散化的过程。在光栅化的过程中，将像素点的中心位置来进行比较，判断像素中心是否在三角形中，在三角形中的像素点，我们就将其显示出来。</p>
<p>具体的判断过程，我们可以使用第二节课中所的叉乘，将三角形三边设置为首尾相连的向量，并通过叉乘来对点进行计算，如果结果符号相同则在三角形内，否则不在。</p>
<p>如果一个点在两个三角形的边界上，我们可以自己设定其显示规则。在OpenGl等api中则有自己的特殊规定。</p>
</li>
</ol>
<p>但是在上述的第二步中，如果对每个三角形都要对所有像素点进行判断，是十分不合理的，所以我们可以作三角形的包围矩形，并且只对矩形中的像素点进行遍历即可。</p>
<p>但是由于光栅化的原因，我们的图片会出现锯齿问题（因为像素本身有大小，然后使用离散化的方法采样，就会导致该问题）。</p>
<p>下节课会解决这些问题。</p>
<h2 id="第六课"><a href="#第六课" class="headerlink" title="第六课"></a>第六课</h2><p>图形学中我们是如何实现反走样的？</p>
<h3 id="抗锯齿和反走样"><a href="#抗锯齿和反走样" class="headerlink" title="抗锯齿和反走样"></a>抗锯齿和反走样</h3>
<p>上图为锯齿</p>
<p>采样就是采集离散样本，例如照片的像素点颜色、视频的每一帧。采样是广泛存在的，但是采样会产生很多的瑕疵，产生的锯齿、摩尔纹、车轮效应等都是采样带来的问题。走样一般是信号变化过快导致的。</p>
<p><strong>解决办法：</strong></p>
<p>对于锯齿来说，我们可以在采样前将采样对象进行模糊处理，再采样（也就是对原始信号做一个滤波）。下图为模糊后的处理效果：<br></p>

<p>我们能否先采样，再对结果进行模糊是否可行呢？</p>
<p><strong>不可行！！</strong></p>
<p>原因：</p>
<p>首先说明频域：</p>
<p><img src="/images/2023-07-10-14-47-36.png" alt></p>
<p>上述两个波的频率为1和2。</p>
<p>傅里叶级数展开：所有函数都可以写成一个sin和cos的函数的线性展开。也就是说可以用多个sin和cos函数的和来无限近似于我们需要展开的函数。</p>
<p>傅里叶变换：给定任意一个函数，我们可以通过一个变换过程变成另外一个，同时也可以通过逆变换变回原来的函数。</p>
<p><img src="/images/2023-07-10-14-53-32.png" alt></p>
<p>走样的原因：同样的方法在采集频率高的波时，会导致获得不同的结果，但是采集低频的波时却没有问题，这就是走样。</p>
<p>频域：一个频率范围中的波函数。</p>
<p>滤波：过滤频域。</p>
<p>有了上述知识我们来看傅里叶变换：<br><img src="/images/2023-07-10-15-04-35.png" alt></p>
<p>傅里叶变换的工作是将图像信息变为频率的信息（如上图）。<br>中心为低频区，外围为高频区，这个图片就代表了低频信息较多（因为中间亮度高）。图片中出现的两条十字交叉线是由于变化过程中将图片视为连续的图片，但是图片左右、上下不是连接的，所以会有剧烈变化，从而出现两条线。对称的图片这两条线就不会很清晰。我们称变化后的图片为频谱。</p>
<p>我们使用滤波处理之后：<br><img src="/images/2023-07-10-15-10-51.png" alt></p>
<p>我们过滤了一些高频的信息，我们再通过逆变换还原图像，会发现剩余信息还是有一些作用的。（这里使用的是高通滤波，即高频可通过）</p>
<p>另一种滤波：<br><img src="/images/2023-07-10-15-13-27.png" alt></p>
<p>仅仅保留低频信息，我们会得到一个相对模糊的图片。（此处使用了低通滤波，类似上述高通滤波）。</p>
<p>另一种滤波：<br><img src="/images/2023-07-10-15-15-06.png" alt></p>
<p>将一些高的频率和一些低的频率过滤，我们会得到上图效果。</p>
<p>卷积等于滤波：傅里叶变换后进行滤波操作再进行逆变换后获得的结果是等于使用对应算子(卷积核)进行卷积计算后获得的结果的。</p>
<p>上述内容为数字图像处理相关内容，帮助了自己复习了大二相关课程。</p>
<p> 解决走样的方法：增大采样频率或者是先模糊再采样。 </p>
<p> 模糊操作我们选用什么滤波器呢？</p>
<p> 对一个像素进行滤波：<br> <img src="/images/2023-07-10-15-43-12.png" alt></p>
<p>具体的实现过程中要如何做呢？现在常用的是一种近似的方法（MSAA）。原理：对于任意一个像素，我们将一个像素分为多个像素，然后判断这些像素在图像中和的像素值为多少，再求这些细分像素的平均值并将之作为该点像素值。这是一种离散的方，增加采样点只是为了去求取该点的像素近似值，并没有实质性的提高像素数量。</p>
<p>其他的方法：FXAA（快速近似抗锯齿）、TAA（通过连续帧信息来抗锯齿）。<br>FXAA：获得图片后的处理方式，具体流程为获得图像边界，然后更换边界。<br>TAA：复用上一帧的结果。</p>
<p>超分辨率：通过深度学习的方式来将缺失的细节进行补充。</p>
<p>简单小节：第六课主要是说明了抗锯齿的解决方法。学习了时域和频域上采样的原理，由此得知了走样的产生原因。同时学习了几种解决锯齿的方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/16/games101Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/16/games101Note/" class="post-title-link" itemprop="url">games101笔记1-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-16 18:43:30" itemprop="dateCreated datePublished" datetime="2023-05-16T18:43:30+08:00">2023-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:14" itemprop="dateModified" datetime="2023-08-31T22:44:14+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Games101-Note-1-3"><a href="#Games101-Note-1-3" class="headerlink" title="Games101 Note 1-3"></a>Games101 Note 1-3</h1><h2 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h2><p>CG应用场景：游戏、电影、动画、设计（CAD）、可视化、虚拟现实、GUI、字体设计等等。</p>
<h3 id="1-光栅化"><a href="#1-光栅化" class="headerlink" title="1.光栅化"></a>1.光栅化</h3><h3 id="2-曲面和网格"><a href="#2-曲面和网格" class="headerlink" title="2.曲面和网格"></a>2.曲面和网格</h3><h3 id="3-实时光线追踪"><a href="#3-实时光线追踪" class="headerlink" title="3.实时光线追踪"></a>3.实时光线追踪</h3><h3 id="4-动画"><a href="#4-动画" class="headerlink" title="4.动画"></a>4.动画</h3><p>以及部分课程相关内容的安排，这里不做记录</p>
<h2 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h2><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>图形学依赖于线性代数</p>
<h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>向量表明的是一个方向</p>
<p>向量最重要的两个属性：<br><strong>方向</strong>与<strong>大小</strong></p>
<p>在我们表示方向时使用单位向量</p>
<p><strong>点乘的作用</strong>：光照模型求取法线夹角等、找到一个向量到另一个向量的投影。</p>
<p><strong>投影的作用</strong>：可以将一个向量分解为两个向量，同时用于组成的两个向量相互垂直。同时可以判断两个向量的方向，如果相同点乘为正，如果不同则为负，如果垂直则为0。</p>
<p><strong>叉乘</strong>：叉乘的计算结果为向量，且该向量垂直与前两个向量。<br><img src="/images/2023-05-14-17-09-43.png" alt></p>
<p>上图为叉乘的矩阵计算。</p>
<p>叉乘计算的作用：判断<strong>左右</strong>以及<strong>内外</strong>。例如判断下图的a在b的哪一侧时，使用叉乘就可以通过结果z向量的正负来判断，如果z为正则在左边，如果为负则为右。</p>
<p><img src="/images/2023-05-14-17-12-36.png" alt></p>
<p>如下图我们可以用来判断<strong>内外</strong>，如果在三角形内，则顶点到p的向量分别叉乘各个边向量，都可以得到同一符号的结果（也就是都在左边或者右边），这样就说明其在内部。<br><img src="/images/2023-05-14-17-18-27.png" alt></p>
<p>这一应用可以用于在光栅化的过程中来判断像素点是否在面片内。</p>
<h4 id="矩阵："><a href="#矩阵：" class="headerlink" title="矩阵："></a>矩阵：</h4><p>矩阵：二维形式表示的数组。</p>
<p>这里说明较为麻烦的计算部分：矩阵之间的乘积。</p>
<p>两个矩阵要是能够相乘则会有：<br>（M x <em>N</em>）（<em>N</em> x P） = （M x P）</p>
<p>可以相乘两个矩阵的N是相同的。</p>
<p>具体数值的计算过程可以通过点乘的性质来计算。</p>
<p>不满足交换律、满足结合律。</p>
<p>矩阵的一些操作：</p>
<p>矩阵的转置</p>
<p><img src="/images/2023-05-14-17-31-00.png" alt></p>
<p>单位矩阵</p>
<p><img src="/images/2023-05-14-17-31-53.png" alt></p>
<p>可以用矩阵的乘法来实现向量的乘法：</p>
<p><img src="/images/2023-05-14-17-35-37.png" alt></p>
<h2 id="第三课"><a href="#第三课" class="headerlink" title="第三课"></a>第三课</h2><p>两种变换：<strong>模型变换</strong>、<strong>视图变换</strong></p>
<p>2D变换：</p>
<p>缩放变换</p>
<p><img src="/images/2023-05-16-09-45-19.png" alt></p>
<p>图片的缩放就是一个2d的缩放变换，将图片的长宽进行线性变换，即</p>
<script type="math/tex; mode=display">
  \begin{bmatrix}
   x'\\
   y'
  \end{bmatrix}
  =
  \begin{bmatrix}
   s & 0\\
   0 & s
  \end{bmatrix}
  \begin{bmatrix}
   x\\
   y
  \end{bmatrix}</script><p>其中s是大小变化的系数，对角矩阵就是缩放矩阵。如果x、y两个方向上缩放的变化大小不相同，那么对角矩阵对应位置的系数也不相同。</p>
<p><img src="/images/2023-05-16-09-56-00.png" alt><br>如果想要要完成上述的变换效果（shear）<br>我们就可以尝试对点的变化来找到线性变换的位置关系，例如原本的左上角点（0，1）变为了（a，1），由此我们可以知道，最上方的一条边上所有点的x方向移动距离都是a，继续向下可以知道每一个点的移动距离都是a*y。那么我们基于这样结论，可以得到以下式子：</p>
<script type="math/tex; mode=display">
 \begin{bmatrix}
  x'\\
  y'
 \end{bmatrix}
 =
 \begin{bmatrix}
  1 & a\\
  0 & 1
 \end{bmatrix}
 \begin{bmatrix}
  x\\
  y
 \end{bmatrix}</script><p>通过上述例子，我们只需要知道这种变换的前后的xy关系，即可写出这种变换。</p>
<p><strong>关于旋转变换</strong>（较难理解）</p>
<p>不说旋转方向时我们一般按照逆时针方向为一般方向。<br><img src="/images/2023-05-16-10-12-33.png" alt></p>
<p>旋转的矩阵我们可以这样设置：</p>
<script type="math/tex; mode=display">
R_θ=
 \begin{bmatrix}
 cosθ & -sinθ\\
 sinθ & cosθ
 \end{bmatrix}</script><p>具体的推导过程可以参考如下图片：<br><img src="/images/二维旋转矩阵推导.jpg" alt></p>
<p>从上述的集中变换中，我们发现可以将所有的变换变为一个矩阵<em>坐标的形式，我们认为这种变换为<em>*线性变换</em></em>。</p>
<p>关于位置的变换：<br><img src="/images/2023-05-16-10-37-22.png" alt><br>可以表示为：</p>
<script type="math/tex; mode=display">
x'= x+t_x\\
y'= y +t_y</script><p>上述式子我们可以直接表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 x'\\
 y'
\end{bmatrix}
=
\begin{bmatrix}
 a & b\\
 c & d
\end{bmatrix}
\begin{bmatrix}
 x\\
 y
 \end{bmatrix}
 +
 \begin{bmatrix}
 t_x\\
 t_y
 \end{bmatrix}</script><p>我们会发现平移变换会加一个矩阵，不是线性变换，为了使得平移变换也能用线性变换的方式来表示，我们可以引入齐次坐标。</p>
<p>基于二维变换，我们只需要增加一个点的纬度，例如：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x'\\
y'\\
w'
\end{bmatrix}
=
\begin{bmatrix}
1&0&t_x\\
0&1&t_y\\
0&0&1
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
1
\end{bmatrix}
=
\begin{bmatrix}
x+t_x\\
y+t_y\\
1
\end{bmatrix}</script><p><strong>w为1时是点，w为0时时向量</strong></p>
<p>这里说明其次坐标下的各个几何意义，在齐次坐标下，如果为向量时，两个向量相加的结果为向量；两个点相减的i结果为这两个点组成的向量；一个点加一个向量结果为点随着这个向量运动的距离；点加点则代表两个点的中点。</p>
<p>我们的目的是通过增加一个维度，来将使得我们的平移变换可以表示为线性变换。代价是我们需要更多的空间来存储额外的数字（这个代价很小）。</p>
<p><strong>相关的其他变换</strong></p>
<p>逆变换：</p>
<p><img src="/images/2023-05-16-10-59-15.png" alt></p>
<p>经过一个M的矩阵变换后再经过一个反过来的操作就会变回原样。</p>
<p>混合变换：</p>
<p><img src="/images/2023-05-16-11-04-54.png" alt></p>
<p>上图的变换过程我们可以通过先旋转再平移来实现。<br>不能先平移再旋转的原因是我们的旋转矩阵的旋转中心是原点，如果先平移后旋转，那么旋转就是以平移后的中心点以原点为中心进行旋转，不能达到目的。具体效果可看下图：</p>
<p><img src="/images/2023-05-16-11-06-50.png" alt></p>
<p>其中需要注意的是矩阵没有交换律，但是有结合律。</p>
<p>变换分解：</p>
<p><img src="/images/2023-05-16-11-13-20.png" alt><br>想要完成上图效果，在该位置上按照左下角的点为原点进行旋转，我们的具体工作过程就可以设置为：</p>
<p>先将左下角的点平移到原点进行一次平移变换，然后旋转，再平移回原来位置。</p>
<p>这个过程就是将一个变换分解为3个步骤来进行。</p>
<p>3D的变换基本上就是增加了一个维度变为3个维度，同时为了使用线性变换来表示，我们会齐次化，从而使用4个数来表示三维空间中的一个点或者向量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://ximu3df.github.io/2023/05/15/PBD%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/logo/logo.png">
      <meta itemprop="name" content="Ximu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ximu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/PBD%E5%B8%83%E6%96%99%E6%A8%A1%E6%8B%9F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">PBD布料模拟算法学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-15 22:09:30" itemprop="dateCreated datePublished" datetime="2023-05-15T22:09:30+08:00">2023-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-31 22:44:16" itemprop="dateModified" datetime="2023-08-31T22:44:16+08:00">2023-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PBD布料模拟算法"><a href="#PBD布料模拟算法" class="headerlink" title="PBD布料模拟算法"></a>PBD布料模拟算法</h1><p>基于位置的动力学（Position Based Dynamics）</p>
<h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p>首先解释一般基于力的模型动画模拟的过程：</p>
<p>通过对某时刻物体进行受力分析，然后获得当前物体所受的合外力，然后基于牛顿第二定理F = ma 来求取加速度，在通过微分的方法来获得当前物体的速度和方向，再通过细化的时间片来使物体的位置发生改变。在图形学中使用这样的方法来模拟运动会导致数据的不稳定，为了使得获得的数据稳定，需要花费更多的算力来进行计算。这不利于在快速输出结果的领域中应用（eg：VR、3d游戏等）。</p>
<p>而基于位置的动力学的模拟方法则可以较好的解决这个问题。</p>
<p>其基本原理为：将所有的仿真对象都模拟成粒子，我们在对这些物体模拟时只考虑粒子，所有的物理学定律都被视为一种<strong>约束</strong>，用于约束粒子的运动。</p>
<p><strong>约束</strong>一般分为两种：</p>
<p>外部约束：物体本身与物体之外产生的力的影响。（重力、碰撞等）</p>
<p>内部约束：物体自身内部产生的约束。（应力等）</p>
<p>基于约束的思想，我们可以得到PBD的基本流程：</p>
<ol>
<li>忽略内部的约束，让每个粒子都接收外部约束，并更新粒子的位置。</li>
<li><strong>计算内部约束，通过内部约束来对受外部约束影响的粒子的位置进行修正。</strong></li>
<li>更具位置的差反过来求速度。</li>
</ol>
<p>对于布料来说，我们需要考虑的问题就是布料对象中，粒子的约束要如何来表达。这里使用gamse103课程中的布料模拟相关内容中的部分内容来说明。</p>
<h2 id="布料模拟"><a href="#布料模拟" class="headerlink" title="布料模拟"></a>布料模拟</h2><p>上述第二点关于粒子运动方向内容的部分代码如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Strain_Limiting</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		Mesh mesh = GetComponent&lt;MeshFilter&gt; ().mesh;</span><br><span class="line">		Vector3[] vertices = mesh.vertices;<span class="comment">//顶点位置信息</span></span><br><span class="line">		Vector3[] sum_x = <span class="keyword">new</span> Vector3[vertices.Length];<span class="comment">//顶点更新后的位置</span></span><br><span class="line">		<span class="built_in">int</span>[] sum_n = <span class="keyword">new</span> <span class="built_in">int</span>[vertices.Length];<span class="comment">//当前顶点连接的其他顶点的数量</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//置0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;sum_n.Length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">			sum_n[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sum_x.Length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum_x[i] = <span class="keyword">new</span> Vector3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// TODO 求出投影总位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> e = <span class="number">0</span>; e &lt; E.Length/<span class="number">2</span>; e++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">int</span> i = E[e * <span class="number">2</span>];</span><br><span class="line">			<span class="built_in">int</span> j = E[e * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">			<span class="built_in">float</span> l = L[e];</span><br><span class="line"></span><br><span class="line">			sum_x[i] = sum_x[i] + <span class="number">0.5f</span> * (vertices[i] + vertices[j] + l * (vertices[i] - vertices[j]).normalized);</span><br><span class="line">			sum_x[j] = sum_x[j] + <span class="number">0.5f</span> * (vertices[i] + vertices[j] - l * (vertices[i] - vertices[j]).normalized);</span><br><span class="line">			sum_n[i]++;</span><br><span class="line">			sum_n[j]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// TODO 根据总位置求出平均位置，赋值给顶点，并根据位移变化求出速度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; vertices.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">20</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			V[i] += inv_t * (((<span class="number">0.2f</span> * vertices[i] + sum_x[i]) / (<span class="number">0.2f</span> + sum_n[i])) - vertices[i]);<span class="comment">//按照实验要求计算</span></span><br><span class="line">			vertices[i] = (<span class="number">0.2f</span> * vertices[i] + sum_x[i]) / (<span class="number">0.2f</span> + sum_n[i]);<span class="comment">//按照实验要求计算</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mesh.vertices = vertices;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以对上述代码进行分析：</p>
<p>在求粒子位置的过程中，我们的输入内容为：模型的顶点位置信息。输出内容为更新后的顶点位置信息。在这个过程中，我们具体做的就是通过设置应变力来作为约束，对当前粒子的位置进行修正。具体思路为：通过两个用来存储顶点位置和顶点连接数的数组</p>
<p>具体的工作过程为：</p>
<ol>
<li>创建对应的数据结构并将其初始状态设置为0。具体内容包括有：存储更新后位置的信息、顶点连接的其他顶点的数量。也就是说初始力收到的力为0。</li>
<li>对每一个边进行访问，这里我们把每一个边当做一个弹簧，通过遍历这些弹簧，来把力叠加到节点上（因为内部粒子间都是连通的，所以力会叠加到之后的节点）。</li>
<li>通过对这些遍历后获得的顶点位置信息和顶点连接的位置数量来进行模型中各个顶点位置的更新。</li>
</ol>
<p>以上为个人大三实验课程学习相关内容的知识总结，虽然所学内容不够完全解释上述部分代码详细内容，但是如果未来有机会完成games103课程的学习的话会对本文章内容进行更新。</p>
<p>内容参考连接</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/562333262">https://zhuanlan.zhihu.com/p/562333262</a></p>
<p><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/abs/pii/S1047320307000065"><em>Position based dynamics</em></a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ximu"
      src="/logo/logo.png">
  <p class="site-author-name" itemprop="name">Ximu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ximu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
